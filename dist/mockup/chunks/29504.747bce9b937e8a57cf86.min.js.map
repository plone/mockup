{"version":3,"file":"chunks/29504.747bce9b937e8a57cf86.min.js","mappings":"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","sources":["webpack://@plone/mockup/./node_modules/tinymce/plugins/advlist/plugin.js"],"sourcesContent":["/**\n * TinyMCE version 7.7.0 (TBD)\n */\n\n(function () {\n    'use strict';\n\n    var global$1 = tinymce.util.Tools.resolve('tinymce.PluginManager');\n\n    const applyListFormat = (editor, listName, styleValue) => {\n      const cmd = listName === 'UL' ? 'InsertUnorderedList' : 'InsertOrderedList';\n      editor.execCommand(cmd, false, styleValue === false ? null : { 'list-style-type': styleValue });\n    };\n\n    const register$2 = editor => {\n      editor.addCommand('ApplyUnorderedListStyle', (ui, value) => {\n        applyListFormat(editor, 'UL', value['list-style-type']);\n      });\n      editor.addCommand('ApplyOrderedListStyle', (ui, value) => {\n        applyListFormat(editor, 'OL', value['list-style-type']);\n      });\n    };\n\n    const option = name => editor => editor.options.get(name);\n    const register$1 = editor => {\n      const registerOption = editor.options.register;\n      registerOption('advlist_number_styles', {\n        processor: 'string[]',\n        default: 'default,lower-alpha,lower-greek,lower-roman,upper-alpha,upper-roman'.split(',')\n      });\n      registerOption('advlist_bullet_styles', {\n        processor: 'string[]',\n        default: 'default,circle,square'.split(',')\n      });\n    };\n    const getNumberStyles = option('advlist_number_styles');\n    const getBulletStyles = option('advlist_bullet_styles');\n\n    const isNullable = a => a === null || a === undefined;\n    const isNonNullable = a => !isNullable(a);\n\n    class Optional {\n      constructor(tag, value) {\n        this.tag = tag;\n        this.value = value;\n      }\n      static some(value) {\n        return new Optional(true, value);\n      }\n      static none() {\n        return Optional.singletonNone;\n      }\n      fold(onNone, onSome) {\n        if (this.tag) {\n          return onSome(this.value);\n        } else {\n          return onNone();\n        }\n      }\n      isSome() {\n        return this.tag;\n      }\n      isNone() {\n        return !this.tag;\n      }\n      map(mapper) {\n        if (this.tag) {\n          return Optional.some(mapper(this.value));\n        } else {\n          return Optional.none();\n        }\n      }\n      bind(binder) {\n        if (this.tag) {\n          return binder(this.value);\n        } else {\n          return Optional.none();\n        }\n      }\n      exists(predicate) {\n        return this.tag && predicate(this.value);\n      }\n      forall(predicate) {\n        return !this.tag || predicate(this.value);\n      }\n      filter(predicate) {\n        if (!this.tag || predicate(this.value)) {\n          return this;\n        } else {\n          return Optional.none();\n        }\n      }\n      getOr(replacement) {\n        return this.tag ? this.value : replacement;\n      }\n      or(replacement) {\n        return this.tag ? this : replacement;\n      }\n      getOrThunk(thunk) {\n        return this.tag ? this.value : thunk();\n      }\n      orThunk(thunk) {\n        return this.tag ? this : thunk();\n      }\n      getOrDie(message) {\n        if (!this.tag) {\n          throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n        } else {\n          return this.value;\n        }\n      }\n      static from(value) {\n        return isNonNullable(value) ? Optional.some(value) : Optional.none();\n      }\n      getOrNull() {\n        return this.tag ? this.value : null;\n      }\n      getOrUndefined() {\n        return this.value;\n      }\n      each(worker) {\n        if (this.tag) {\n          worker(this.value);\n        }\n      }\n      toArray() {\n        return this.tag ? [this.value] : [];\n      }\n      toString() {\n        return this.tag ? `some(${ this.value })` : 'none()';\n      }\n    }\n    Optional.singletonNone = new Optional(false);\n\n    const nativeIndexOf = Array.prototype.indexOf;\n    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);\n    const contains = (xs, x) => rawIndexOf(xs, x) > -1;\n    const findUntil = (xs, pred, until) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(x);\n        } else if (until(x, i)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n\n    const keys = Object.keys;\n    const each = (obj, f) => {\n      const props = keys(obj);\n      for (let k = 0, len = props.length; k < len; k++) {\n        const i = props[k];\n        const x = obj[i];\n        f(x, i);\n      }\n    };\n    const map = (obj, f) => {\n      return tupleMap(obj, (x, i) => ({\n        k: i,\n        v: f(x, i)\n      }));\n    };\n    const tupleMap = (obj, f) => {\n      const r = {};\n      each(obj, (x, i) => {\n        const tuple = f(x, i);\n        r[tuple.k] = tuple.v;\n      });\n      return r;\n    };\n\n    var global = tinymce.util.Tools.resolve('tinymce.util.Tools');\n\n    const isCustomList = list => /\\btox\\-/.test(list.className);\n    const isChildOfBody = (editor, elm) => {\n      return editor.dom.isChildOf(elm, editor.getBody());\n    };\n    const matchNodeNames = regex => node => isNonNullable(node) && regex.test(node.nodeName);\n    const isListNode = matchNodeNames(/^(OL|UL|DL)$/);\n    const isTableCellNode = matchNodeNames(/^(TH|TD)$/);\n    const inList = (editor, parents, nodeName) => findUntil(parents, parent => isListNode(parent) && !isCustomList(parent), isTableCellNode).exists(list => list.nodeName === nodeName && isChildOfBody(editor, list));\n    const getSelectedStyleType = editor => {\n      const listElm = editor.dom.getParent(editor.selection.getNode(), 'ol,ul');\n      const style = editor.dom.getStyle(listElm, 'listStyleType');\n      return Optional.from(style);\n    };\n    const isWithinNonEditable = (editor, element) => element !== null && !editor.dom.isEditable(element);\n    const isWithinNonEditableList = (editor, element) => {\n      const parentList = editor.dom.getParent(element, 'ol,ul,dl');\n      return isWithinNonEditable(editor, parentList) || !editor.selection.isEditable();\n    };\n    const setNodeChangeHandler = (editor, nodeChangeHandler) => {\n      const initialNode = editor.selection.getNode();\n      nodeChangeHandler({\n        parents: editor.dom.getParents(initialNode),\n        element: initialNode\n      });\n      editor.on('NodeChange', nodeChangeHandler);\n      return () => editor.off('NodeChange', nodeChangeHandler);\n    };\n\n    const styleValueToText = styleValue => {\n      return styleValue.replace(/\\-/g, ' ').replace(/\\b\\w/g, chr => {\n        return chr.toUpperCase();\n      });\n    };\n    const normalizeStyleValue = styleValue => isNullable(styleValue) || styleValue === 'default' ? '' : styleValue;\n    const makeSetupHandler = (editor, nodeName) => api => {\n      const updateButtonState = (editor, parents) => {\n        const element = editor.selection.getStart(true);\n        api.setActive(inList(editor, parents, nodeName));\n        api.setEnabled(!isWithinNonEditableList(editor, element));\n      };\n      const nodeChangeHandler = e => updateButtonState(editor, e.parents);\n      return setNodeChangeHandler(editor, nodeChangeHandler);\n    };\n    const addSplitButton = (editor, id, tooltip, cmd, nodeName, styles) => {\n      const listStyleTypeAliases = {\n        'lower-latin': 'lower-alpha',\n        'upper-latin': 'upper-alpha',\n        'lower-alpha': 'lower-latin',\n        'upper-alpha': 'upper-latin'\n      };\n      const stylesContainsAliasMap = map(listStyleTypeAliases, alias => contains(styles, alias));\n      editor.ui.registry.addSplitButton(id, {\n        tooltip,\n        icon: nodeName === 'OL' ? 'ordered-list' : 'unordered-list',\n        presets: 'listpreview',\n        columns: 3,\n        fetch: callback => {\n          const items = global.map(styles, styleValue => {\n            const iconStyle = nodeName === 'OL' ? 'num' : 'bull';\n            const iconName = styleValue === 'disc' || styleValue === 'decimal' ? 'default' : styleValue;\n            const itemValue = normalizeStyleValue(styleValue);\n            const displayText = styleValueToText(styleValue);\n            return {\n              type: 'choiceitem',\n              value: itemValue,\n              icon: 'list-' + iconStyle + '-' + iconName,\n              text: displayText\n            };\n          });\n          callback(items);\n        },\n        onAction: () => editor.execCommand(cmd),\n        onItemAction: (_splitButtonApi, value) => {\n          applyListFormat(editor, nodeName, value);\n        },\n        select: value => {\n          const listStyleType = getSelectedStyleType(editor);\n          return listStyleType.exists(listStyle => value === listStyle || listStyleTypeAliases[listStyle] === value && !stylesContainsAliasMap[value]);\n        },\n        onSetup: makeSetupHandler(editor, nodeName)\n      });\n    };\n    const addButton = (editor, id, tooltip, cmd, nodeName, styleValue) => {\n      editor.ui.registry.addToggleButton(id, {\n        active: false,\n        tooltip,\n        icon: nodeName === 'OL' ? 'ordered-list' : 'unordered-list',\n        onSetup: makeSetupHandler(editor, nodeName),\n        onAction: () => editor.queryCommandState(cmd) || styleValue === '' ? editor.execCommand(cmd) : applyListFormat(editor, nodeName, styleValue)\n      });\n    };\n    const addControl = (editor, id, tooltip, cmd, nodeName, styles) => {\n      if (styles.length > 1) {\n        addSplitButton(editor, id, tooltip, cmd, nodeName, styles);\n      } else {\n        addButton(editor, id, tooltip, cmd, nodeName, normalizeStyleValue(styles[0]));\n      }\n    };\n    const register = editor => {\n      addControl(editor, 'numlist', 'Numbered list', 'InsertOrderedList', 'OL', getNumberStyles(editor));\n      addControl(editor, 'bullist', 'Bullet list', 'InsertUnorderedList', 'UL', getBulletStyles(editor));\n    };\n\n    var Plugin = () => {\n      global$1.add('advlist', editor => {\n        if (editor.hasPlugin('lists')) {\n          register$1(editor);\n          register(editor);\n          register$2(editor);\n        } else {\n          console.error('Please use the Lists plugin together with the List Styles plugin.');\n        }\n      });\n    };\n\n    Plugin();\n\n})();\n"],"names":["global$1","tinymce","util","Tools","resolve","applyListFormat","editor","listName","styleValue","cmd","execCommand","option","name","options","get","getNumberStyles","getBulletStyles","isNullable","a","isNonNullable","Optional","constructor","tag","value","this","some","none","singletonNone","fold","onNone","onSome","isSome","isNone","map","mapper","bind","binder","exists","predicate","forall","filter","getOr","replacement","or","getOrThunk","thunk","orThunk","getOrDie","message","Error","from","getOrNull","getOrUndefined","each","worker","toArray","toString","nativeIndexOf","Array","prototype","indexOf","contains","xs","x","rawIndexOf","ts","t","call","keys","Object","tupleMap","obj","f","r","props","k","len","length","i","tuple","v","global","matchNodeNames","regex","node","test","nodeName","isListNode","isTableCellNode","inList","parents","pred","until","findUntil","parent","className","list","elm","dom","isChildOf","getBody","isChildOfBody","normalizeStyleValue","makeSetupHandler","api","nodeChangeHandler","initialNode","selection","getNode","getParents","element","on","off","setNodeChangeHandler","e","getStart","setActive","setEnabled","parentList","getParent","isEditable","isWithinNonEditable","isWithinNonEditableList","updateButtonState","addSplitButton","id","tooltip","styles","listStyleTypeAliases","stylesContainsAliasMap","alias","ui","registry","icon","presets","columns","fetch","callback","iconStyle","iconName","itemValue","displayText","replace","chr","toUpperCase","styleValueToText","type","text","onAction","onItemAction","_splitButtonApi","select","listStyleType","listElm","style","getStyle","getSelectedStyleType","listStyle","onSetup","addControl","addToggleButton","active","queryCommandState","addButton","add","hasPlugin","registerOption","register","processor","default","split","register$1","addCommand","register$2","console","error"],"sourceRoot":""}