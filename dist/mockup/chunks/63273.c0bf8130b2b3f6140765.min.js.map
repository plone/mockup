{"version":3,"file":"chunks/63273.c0bf8130b2b3f6140765.min.js","mappings":"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","sources":["webpack://@plone/mockup/./node_modules/tinymce/plugins/accordion/plugin.js"],"sourcesContent":["/**\n * TinyMCE version 7.9.1 (2025-05-29)\n */\n\n(function () {\n    'use strict';\n\n    var global$4 = tinymce.util.Tools.resolve('tinymce.PluginManager');\n\n    /* eslint-disable @typescript-eslint/no-wrapper-object-types */\n    const hasProto = (v, constructor, predicate) => {\n        var _a;\n        if (predicate(v, constructor.prototype)) {\n            return true;\n        }\n        else {\n            // String-based fallback time\n            return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n        }\n    };\n    const typeOf = (x) => {\n        const t = typeof x;\n        if (x === null) {\n            return 'null';\n        }\n        else if (t === 'object' && Array.isArray(x)) {\n            return 'array';\n        }\n        else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n            return 'string';\n        }\n        else {\n            return t;\n        }\n    };\n    const isType$1 = (type) => (value) => typeOf(value) === type;\n    const isSimpleType = (type) => (value) => typeof value === type;\n    const isString = isType$1('string');\n    const isBoolean = isSimpleType('boolean');\n    const isNullable = (a) => a === null || a === undefined;\n    const isNonNullable = (a) => !isNullable(a);\n    const isFunction = isSimpleType('function');\n    const isNumber = isSimpleType('number');\n\n    /** Compose two unary functions. Similar to compose, but avoids using Function.prototype.apply. */\n    const compose1 = (fbc, fab) => (a) => fbc(fab(a));\n    const constant = (value) => {\n        return () => {\n            return value;\n        };\n    };\n    const tripleEquals = (a, b) => {\n        return a === b;\n    };\n    const never = constant(false);\n\n    /**\n     * The `Optional` type represents a value (of any type) that potentially does\n     * not exist. Any `Optional<T>` can either be a `Some<T>` (in which case the\n     * value does exist) or a `None` (in which case the value does not exist). This\n     * module defines a whole lot of FP-inspired utility functions for dealing with\n     * `Optional` objects.\n     *\n     * Comparison with null or undefined:\n     * - We don't get fancy null coalescing operators with `Optional`\n     * - We do get fancy helper functions with `Optional`\n     * - `Optional` support nesting, and allow for the type to still be nullable (or\n     * another `Optional`)\n     * - There is no option to turn off strict-optional-checks like there is for\n     * strict-null-checks\n     */\n    class Optional {\n        // The internal representation has a `tag` and a `value`, but both are\n        // private: able to be console.logged, but not able to be accessed by code\n        constructor(tag, value) {\n            this.tag = tag;\n            this.value = value;\n        }\n        // --- Identities ---\n        /**\n         * Creates a new `Optional<T>` that **does** contain a value.\n         */\n        static some(value) {\n            return new Optional(true, value);\n        }\n        /**\n         * Create a new `Optional<T>` that **does not** contain a value. `T` can be\n         * any type because we don't actually have a `T`.\n         */\n        static none() {\n            return Optional.singletonNone;\n        }\n        /**\n         * Perform a transform on an `Optional` type. Regardless of whether this\n         * `Optional` contains a value or not, `fold` will return a value of type `U`.\n         * If this `Optional` does not contain a value, the `U` will be created by\n         * calling `onNone`. If this `Optional` does contain a value, the `U` will be\n         * created by calling `onSome`.\n         *\n         * For the FP enthusiasts in the room, this function:\n         * 1. Could be used to implement all of the functions below\n         * 2. Forms a catamorphism\n         */\n        fold(onNone, onSome) {\n            if (this.tag) {\n                return onSome(this.value);\n            }\n            else {\n                return onNone();\n            }\n        }\n        /**\n         * Determine if this `Optional` object contains a value.\n         */\n        isSome() {\n            return this.tag;\n        }\n        /**\n         * Determine if this `Optional` object **does not** contain a value.\n         */\n        isNone() {\n            return !this.tag;\n        }\n        // --- Functor (name stolen from Haskell / maths) ---\n        /**\n         * Perform a transform on an `Optional` object, **if** there is a value. If\n         * you provide a function to turn a T into a U, this is the function you use\n         * to turn an `Optional<T>` into an `Optional<U>`. If this **does** contain\n         * a value then the output will also contain a value (that value being the\n         * output of `mapper(this.value)`), and if this **does not** contain a value\n         * then neither will the output.\n         */\n        map(mapper) {\n            if (this.tag) {\n                return Optional.some(mapper(this.value));\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Monad (name stolen from Haskell / maths) ---\n        /**\n         * Perform a transform on an `Optional` object, **if** there is a value.\n         * Unlike `map`, here the transform itself also returns an `Optional`.\n         */\n        bind(binder) {\n            if (this.tag) {\n                return binder(this.value);\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Traversable (name stolen from Haskell / maths) ---\n        /**\n         * For a given predicate, this function finds out if there **exists** a value\n         * inside this `Optional` object that meets the predicate. In practice, this\n         * means that for `Optional`s that do not contain a value it returns false (as\n         * no predicate-meeting value exists).\n         */\n        exists(predicate) {\n            return this.tag && predicate(this.value);\n        }\n        /**\n         * For a given predicate, this function finds out if **all** the values inside\n         * this `Optional` object meet the predicate. In practice, this means that\n         * for `Optional`s that do not contain a value it returns true (as all 0\n         * objects do meet the predicate).\n         */\n        forall(predicate) {\n            return !this.tag || predicate(this.value);\n        }\n        filter(predicate) {\n            if (!this.tag || predicate(this.value)) {\n                return this;\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Getters ---\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value.\n         */\n        getOr(replacement) {\n            return this.tag ? this.value : replacement;\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value.  Unlike `getOr`, in this method the `replacement` object is also\n         * `Optional` - meaning that this method will always return an `Optional`.\n         */\n        or(replacement) {\n            return this.tag ? this : replacement;\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value. Unlike `getOr`, in this method the `replacement` value is\n         * \"thunked\" - that is to say that you don't pass a value to `getOrThunk`, you\n         * pass a function which (if called) will **return** the `value` you want to\n         * use.\n         */\n        getOrThunk(thunk) {\n            return this.tag ? this.value : thunk();\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided Optional object does not contain a\n         * value.\n         *\n         * Unlike `or`, in this method the `replacement` value is \"thunked\" - that is\n         * to say that you don't pass a value to `orThunk`, you pass a function which\n         * (if called) will **return** the `value` you want to use.\n         *\n         * Unlike `getOrThunk`, in this method the `replacement` value is also\n         * `Optional`, meaning that this method will always return an `Optional`.\n         */\n        orThunk(thunk) {\n            return this.tag ? this : thunk();\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, throwing an\n         * exception if the provided `Optional` object does not contain a value.\n         *\n         * WARNING:\n         * You should only be using this function if you know that the `Optional`\n         * object **is not** empty (otherwise you're throwing exceptions in production\n         * code, which is bad).\n         *\n         * In tests this is more acceptable.\n         *\n         * Prefer other methods to this, such as `.each`.\n         */\n        getOrDie(message) {\n            if (!this.tag) {\n                throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n            }\n            else {\n                return this.value;\n            }\n        }\n        // --- Interop with null and undefined ---\n        /**\n         * Creates an `Optional` value from a nullable (or undefined-able) input.\n         * Null, or undefined, is converted to `None`, and anything else is converted\n         * to `Some`.\n         */\n        static from(value) {\n            return isNonNullable(value) ? Optional.some(value) : Optional.none();\n        }\n        /**\n         * Converts an `Optional` to a nullable type, by getting the value if it\n         * exists, or returning `null` if it does not.\n         */\n        getOrNull() {\n            return this.tag ? this.value : null;\n        }\n        /**\n         * Converts an `Optional` to an undefined-able type, by getting the value if\n         * it exists, or returning `undefined` if it does not.\n         */\n        getOrUndefined() {\n            return this.value;\n        }\n        // --- Utilities ---\n        /**\n         * If the `Optional` contains a value, perform an action on that value.\n         * Unlike the rest of the methods on this type, `.each` has side-effects. If\n         * you want to transform an `Optional<T>` **into** something, then this is not\n         * the method for you. If you want to use an `Optional<T>` to **do**\n         * something, then this is the method for you - provided you're okay with not\n         * doing anything in the case where the `Optional` doesn't have a value inside\n         * it. If you're not sure whether your use-case fits into transforming\n         * **into** something or **doing** something, check whether it has a return\n         * value. If it does, you should be performing a transform.\n         */\n        each(worker) {\n            if (this.tag) {\n                worker(this.value);\n            }\n        }\n        /**\n         * Turn the `Optional` object into an array that contains all of the values\n         * stored inside the `Optional`. In practice, this means the output will have\n         * either 0 or 1 elements.\n         */\n        toArray() {\n            return this.tag ? [this.value] : [];\n        }\n        /**\n         * Turn the `Optional` object into a string for debugging or printing. Not\n         * recommended for production code, but good for debugging. Also note that\n         * these days an `Optional` object can be logged to the console directly, and\n         * its inner value (if it exists) will be visible.\n         */\n        toString() {\n            return this.tag ? `some(${this.value})` : 'none()';\n        }\n    }\n    // Sneaky optimisation: every instance of Optional.none is identical, so just\n    // reuse the same object\n    Optional.singletonNone = new Optional(false);\n\n    const nativeIndexOf = Array.prototype.indexOf;\n    /* eslint-enable */\n    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);\n    const contains = (xs, x) => rawIndexOf(xs, x) > -1;\n    const map = (xs, f) => {\n        // pre-allocating array size when it's guaranteed to be known\n        // http://jsperf.com/push-allocated-vs-dynamic/22\n        const len = xs.length;\n        const r = new Array(len);\n        for (let i = 0; i < len; i++) {\n            const x = xs[i];\n            r[i] = f(x, i);\n        }\n        return r;\n    };\n    // Unwound implementing other functions in terms of each.\n    // The code size is roughly the same, and it should allow for better optimisation.\n    // const each = function<T, U>(xs: T[], f: (x: T, i?: number, xs?: T[]) => void): void {\n    const each$1 = (xs, f) => {\n        for (let i = 0, len = xs.length; i < len; i++) {\n            const x = xs[i];\n            f(x, i);\n        }\n    };\n    const filter = (xs, pred) => {\n        const r = [];\n        for (let i = 0, len = xs.length; i < len; i++) {\n            const x = xs[i];\n            if (pred(x, i)) {\n                r.push(x);\n            }\n        }\n        return r;\n    };\n    const foldl = (xs, f, acc) => {\n        each$1(xs, (x, i) => {\n            acc = f(acc, x, i);\n        });\n        return acc;\n    };\n\n    // There are many variations of Object iteration that are faster than the 'for-in' style:\n    // http://jsperf.com/object-keys-iteration/107\n    //\n    // Use the native keys if it is available (IE9+), otherwise fall back to manually filtering\n    const keys = Object.keys;\n    const each = (obj, f) => {\n        const props = keys(obj);\n        for (let k = 0, len = props.length; k < len; k++) {\n            const i = props[k];\n            const x = obj[i];\n            f(x, i);\n        }\n    };\n\n    /**\n     * Adds two numbers, and wrap to a range.\n     * If the result overflows to the right, snap to the left.\n     * If the result overflows to the left, snap to the right.\n     */\n    // the division is meant to get a number between 0 and 1 for more information check this discussion: https://stackoverflow.com/questions/58285941/how-to-replace-math-random-with-crypto-getrandomvalues-and-keep-same-result\n    const random = () => window.crypto.getRandomValues(new Uint32Array(1))[0] / 4294967295;\n\n    /**\n     * Generate a unique identifier.\n     *\n     * The unique portion of the identifier only contains an underscore\n     * and digits, so that it may safely be used within HTML attributes.\n     *\n     * The chance of generating a non-unique identifier has been minimized\n     * by combining the current time, a random number and a one-up counter.\n     *\n     * generate :: String -> String\n     */\n    let unique = 0;\n    const generate = (prefix) => {\n        const date = new Date();\n        const time = date.getTime();\n        const random$1 = Math.floor(random() * 1000000000);\n        unique++;\n        return prefix + '_' + random$1 + unique + String(time);\n    };\n\n    /**\n     * **Is** the value stored inside this Optional object equal to `rhs`?\n     */\n    const is$2 = (lhs, rhs, comparator = tripleEquals) => lhs.exists((left) => comparator(left, rhs));\n\n    const blank = (r) => (s) => s.replace(r, '');\n    /** removes all leading and trailing spaces */\n    const trim = blank(/^\\s+|\\s+$/g);\n\n    const point = (element, offset) => ({\n        element,\n        offset\n    });\n\n    const fromHtml = (html, scope) => {\n        const doc = scope || document;\n        const div = doc.createElement('div');\n        div.innerHTML = html;\n        if (!div.hasChildNodes() || div.childNodes.length > 1) {\n            const message = 'HTML does not have a single root node';\n            // eslint-disable-next-line no-console\n            console.error(message, html);\n            throw new Error(message);\n        }\n        return fromDom(div.childNodes[0]);\n    };\n    const fromTag = (tag, scope) => {\n        const doc = scope || document;\n        const node = doc.createElement(tag);\n        return fromDom(node);\n    };\n    const fromText = (text, scope) => {\n        const doc = scope || document;\n        const node = doc.createTextNode(text);\n        return fromDom(node);\n    };\n    const fromDom = (node) => {\n        // TODO: Consider removing this check, but left atm for safety\n        if (node === null || node === undefined) {\n            throw new Error('Node cannot be null or undefined');\n        }\n        return {\n            dom: node\n        };\n    };\n    const fromPoint = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom);\n    // tslint:disable-next-line:variable-name\n    const SugarElement = {\n        fromHtml,\n        fromTag,\n        fromText,\n        fromDom,\n        fromPoint\n    };\n\n    const COMMENT = 8;\n    const DOCUMENT = 9;\n    const DOCUMENT_FRAGMENT = 11;\n    const ELEMENT = 1;\n    const TEXT = 3;\n\n    const is$1 = (element, selector) => {\n        const dom = element.dom;\n        if (dom.nodeType !== ELEMENT) {\n            return false;\n        }\n        else {\n            const elem = dom;\n            if (elem.matches !== undefined) {\n                return elem.matches(selector);\n            }\n            else if (elem.msMatchesSelector !== undefined) {\n                return elem.msMatchesSelector(selector);\n            }\n            else if (elem.webkitMatchesSelector !== undefined) {\n                return elem.webkitMatchesSelector(selector);\n            }\n            else if (elem.mozMatchesSelector !== undefined) {\n                // cast to any as mozMatchesSelector doesn't exist in TS DOM lib\n                return elem.mozMatchesSelector(selector);\n            }\n            else {\n                throw new Error('Browser lacks native selectors');\n            } // unfortunately we can't throw this on startup :(\n        }\n    };\n    const bypassSelector = (dom) => \n    // Only elements, documents and shadow roots support querySelector\n    // shadow root element type is DOCUMENT_FRAGMENT\n    dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT ||\n        // IE fix for complex queries on empty nodes: http://jsfiddle.net/spyder/fv9ptr5L/\n        dom.childElementCount === 0;\n    const all = (selector, scope) => {\n        const base = scope === undefined ? document : scope.dom;\n        return bypassSelector(base) ? [] : map(base.querySelectorAll(selector), SugarElement.fromDom);\n    };\n    const one = (selector, scope) => {\n        const base = scope === undefined ? document : scope.dom;\n        return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);\n    };\n\n    const eq = (e1, e2) => e1.dom === e2.dom;\n    const is = is$1;\n\n    const name = (element) => {\n        const r = element.dom.nodeName;\n        return r.toLowerCase();\n    };\n    const type = (element) => element.dom.nodeType;\n    const isType = (t) => (element) => type(element) === t;\n    const isComment = (element) => type(element) === COMMENT || name(element) === '#comment';\n    const isElement = isType(ELEMENT);\n    const isText = isType(TEXT);\n    const isDocument = isType(DOCUMENT);\n    const isDocumentFragment = isType(DOCUMENT_FRAGMENT);\n\n    /**\n     * The document associated with the current element\n     * NOTE: this will throw if the owner is null.\n     */\n    const owner = (element) => SugarElement.fromDom(element.dom.ownerDocument);\n    /**\n     * If the element is a document, return it. Otherwise, return its ownerDocument.\n     * @param dos\n     */\n    const documentOrOwner = (dos) => isDocument(dos) ? dos : owner(dos);\n    const parent = (element) => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n    const parents = (element, isRoot) => {\n        const stop = isFunction(isRoot) ? isRoot : never;\n        // This is used a *lot* so it needs to be performant, not recursive\n        let dom = element.dom;\n        const ret = [];\n        while (dom.parentNode !== null && dom.parentNode !== undefined) {\n            const rawParent = dom.parentNode;\n            const p = SugarElement.fromDom(rawParent);\n            ret.push(p);\n            if (stop(p) === true) {\n                break;\n            }\n            else {\n                dom = rawParent;\n            }\n        }\n        return ret;\n    };\n    const prevSibling = (element) => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);\n    const nextSibling = (element) => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);\n    const children = (element) => map(element.dom.childNodes, SugarElement.fromDom);\n    const child = (element, index) => {\n        const cs = element.dom.childNodes;\n        return Optional.from(cs[index]).map(SugarElement.fromDom);\n    };\n    const firstChild = (element) => child(element, 0);\n\n    /**\n     * Is the element a ShadowRoot?\n     *\n     * Note: this is insufficient to test if any element is a shadow root, but it is sufficient to differentiate between\n     * a Document and a ShadowRoot.\n     */\n    const isShadowRoot = (dos) => isDocumentFragment(dos) && isNonNullable(dos.dom.host);\n    const getRootNode = (e) => SugarElement.fromDom(e.dom.getRootNode());\n    /** If this element is in a ShadowRoot, return it. */\n    const getShadowRoot = (e) => {\n        const r = getRootNode(e);\n        return isShadowRoot(r) ? Optional.some(r) : Optional.none();\n    };\n    /** Return the host of a ShadowRoot.\n     *\n     * This function will throw if Shadow DOM is unsupported in the browser, or if the host is null.\n     * If you actually have a ShadowRoot, this shouldn't happen.\n     */\n    const getShadowHost = (e) => SugarElement.fromDom(e.dom.host);\n\n    const before = (marker, element) => {\n        const parent$1 = parent(marker);\n        parent$1.each((v) => {\n            v.dom.insertBefore(element.dom, marker.dom);\n        });\n    };\n    const after$1 = (marker, element) => {\n        const sibling = nextSibling(marker);\n        sibling.fold(() => {\n            const parent$1 = parent(marker);\n            parent$1.each((v) => {\n                append$1(v, element);\n            });\n        }, (v) => {\n            before(v, element);\n        });\n    };\n    const prepend = (parent, element) => {\n        const firstChild$1 = firstChild(parent);\n        firstChild$1.fold(() => {\n            append$1(parent, element);\n        }, (v) => {\n            parent.dom.insertBefore(element.dom, v.dom);\n        });\n    };\n    const append$1 = (parent, element) => {\n        parent.dom.appendChild(element.dom);\n    };\n    const wrap = (element, wrapper) => {\n        before(element, wrapper);\n        append$1(wrapper, element);\n    };\n\n    const after = (marker, elements) => {\n        each$1(elements, (x, i) => {\n            const e = i === 0 ? marker : elements[i - 1];\n            after$1(e, x);\n        });\n    };\n    const append = (parent, elements) => {\n        each$1(elements, (x) => {\n            append$1(parent, x);\n        });\n    };\n\n    const rawSet = (dom, key, value) => {\n        /*\n         * JQuery coerced everything to a string, and silently did nothing on text node/null/undefined.\n         *\n         * We fail on those invalid cases, only allowing numbers and booleans.\n         */\n        if (isString(value) || isBoolean(value) || isNumber(value)) {\n            dom.setAttribute(key, value + '');\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n            throw new Error('Attribute value was not simple');\n        }\n    };\n    const set$2 = (element, key, value) => {\n        rawSet(element.dom, key, value);\n    };\n    const setAll = (element, attrs) => {\n        const dom = element.dom;\n        each(attrs, (v, k) => {\n            rawSet(dom, k, v);\n        });\n    };\n    const get$2 = (element, key) => {\n        const v = element.dom.getAttribute(key);\n        // undefined is the more appropriate value for JS, and this matches JQuery\n        return v === null ? undefined : v;\n    };\n    const getOpt = (element, key) => Optional.from(get$2(element, key));\n    const remove$2 = (element, key) => {\n        element.dom.removeAttribute(key);\n    };\n    const clone = (element) => foldl(element.dom.attributes, (acc, attr) => {\n        acc[attr.name] = attr.value;\n        return acc;\n    }, {});\n\n    const remove$1 = (element) => {\n        const dom = element.dom;\n        if (dom.parentNode !== null) {\n            dom.parentNode.removeChild(dom);\n        }\n    };\n    const unwrap = (wrapper) => {\n        const children$1 = children(wrapper);\n        if (children$1.length > 0) {\n            after(wrapper, children$1);\n        }\n        remove$1(wrapper);\n    };\n\n    // some elements, such as mathml, don't have style attributes\n    // others, such as angular elements, have style attributes that aren't a CSSStyleDeclaration\n    const isSupported = (dom) => \n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    dom.style !== undefined && isFunction(dom.style.getPropertyValue);\n\n    // Node.contains() is very, very, very good performance\n    // http://jsperf.com/closest-vs-contains/5\n    const inBody = (element) => {\n        // Technically this is only required on IE, where contains() returns false for text nodes.\n        // But it's cheap enough to run everywhere and Sugar doesn't have platform detection (yet).\n        const dom = isText(element) ? element.dom.parentNode : element.dom;\n        // use ownerDocument.body to ensure this works inside iframes.\n        // Normally contains is bad because an element \"contains\" itself, but here we want that.\n        if (dom === undefined || dom === null || dom.ownerDocument === null) {\n            return false;\n        }\n        const doc = dom.ownerDocument;\n        return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));\n    };\n\n    const internalSet = (dom, property, value) => {\n        // This is going to hurt. Apologies.\n        // JQuery coerces numbers to pixels for certain property names, and other times lets numbers through.\n        // we're going to be explicit; strings only.\n        if (!isString(value)) {\n            // eslint-disable-next-line no-console\n            console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\n            throw new Error('CSS value must be a string: ' + value);\n        }\n        // removed: support for dom().style[property] where prop is camel case instead of normal property name\n        if (isSupported(dom)) {\n            dom.style.setProperty(property, value);\n        }\n    };\n    const internalRemove = (dom, property) => {\n        /*\n         * IE9 and above - MDN doesn't have details, but here's a couple of random internet claims\n         *\n         * http://help.dottoro.com/ljopsjck.php\n         * http://stackoverflow.com/a/7901886/7546\n         */\n        if (isSupported(dom)) {\n            dom.style.removeProperty(property);\n        }\n    };\n    const set$1 = (element, property, value) => {\n        const dom = element.dom;\n        internalSet(dom, property, value);\n    };\n    /*\n     * NOTE: For certain properties, this returns the \"used value\" which is subtly different to the \"computed value\" (despite calling getComputedStyle).\n     * Blame CSS 2.0.\n     *\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n     */\n    const get$1 = (element, property) => {\n        const dom = element.dom;\n        /*\n         * IE9 and above per\n         * https://developer.mozilla.org/en/docs/Web/API/window.getComputedStyle\n         *\n         * Not in numerosity, because it doesn't memoize and looking this up dynamically in performance critical code would be horrendous.\n         *\n         * JQuery has some magic here for IE popups, but we don't really need that.\n         * It also uses element.ownerDocument.defaultView to handle iframes but that hasn't been required since FF 3.6.\n         */\n        const styles = window.getComputedStyle(dom);\n        const r = styles.getPropertyValue(property);\n        // jquery-ism: If r is an empty string, check that the element is not in a document. If it isn't, return the raw value.\n        // Turns out we do this a lot.\n        return (r === '' && !inBody(element)) ? getUnsafeProperty(dom, property) : r;\n    };\n    // removed: support for dom().style[property] where prop is camel case instead of normal property name\n    // empty string is what the browsers (IE11 and Chrome) return when the propertyValue doesn't exists.\n    const getUnsafeProperty = (dom, property) => isSupported(dom) ? dom.style.getPropertyValue(property) : '';\n    /*\n     * Gets the raw value from the style attribute. Useful for retrieving \"used values\" from the DOM:\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n     *\n     * Returns NONE if the property isn't set, or the value is an empty string.\n     */\n    const getRaw = (element, property) => {\n        const dom = element.dom;\n        const raw = getUnsafeProperty(dom, property);\n        return Optional.from(raw).filter((r) => r.length > 0);\n    };\n    const remove = (element, property) => {\n        const dom = element.dom;\n        internalRemove(dom, property);\n        if (is$2(getOpt(element, 'style').map(trim), '')) {\n            // No more styles left, remove the style attribute as well\n            remove$2(element, 'style');\n        }\n    };\n\n    const NodeValue = (is, name) => {\n        const get = (element) => {\n            if (!is(element)) {\n                throw new Error('Can only get ' + name + ' value of a ' + name + ' node');\n            }\n            return getOption(element).getOr('');\n        };\n        const getOption = (element) => is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();\n        const set = (element, value) => {\n            if (!is(element)) {\n                throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');\n            }\n            element.dom.nodeValue = value;\n        };\n        return {\n            get,\n            getOption,\n            set\n        };\n    };\n\n    const api = NodeValue(isText, 'text');\n    const get = (element) => api.get(element);\n    const set = (element, value) => api.set(element, value);\n\n    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {\n        if (is(scope, a)) {\n            return Optional.some(scope);\n        }\n        else if (isFunction(isRoot) && isRoot(scope)) {\n            return Optional.none();\n        }\n        else {\n            return ancestor(scope, a, isRoot);\n        }\n    };\n\n    const ancestor$1 = (scope, predicate, isRoot) => {\n        let element = scope.dom;\n        const stop = isFunction(isRoot) ? isRoot : never;\n        while (element.parentNode) {\n            element = element.parentNode;\n            const el = SugarElement.fromDom(element);\n            if (predicate(el)) {\n                return Optional.some(el);\n            }\n            else if (stop(el)) {\n                break;\n            }\n        }\n        return Optional.none();\n    };\n\n    const ancestor = (scope, selector, isRoot) => ancestor$1(scope, (e) => is$1(e, selector), isRoot);\n    const descendant = (scope, selector) => one(selector, scope);\n    // Returns Some(closest ancestor element (sugared)) matching 'selector' up to isRoot, or None() otherwise\n    const closest = (scope, selector, isRoot) => {\n        const is = (element, selector) => is$1(element, selector);\n        return ClosestOrAncestor(is, ancestor, scope, selector, isRoot);\n    };\n\n    const descendants$1 = (scope, predicate) => {\n        let result = [];\n        // Recurse.toArray() might help here\n        each$1(children(scope), (x) => {\n            if (predicate(x)) {\n                result = result.concat([x]);\n            }\n            result = result.concat(descendants$1(x, predicate));\n        });\n        return result;\n    };\n\n    const descendants = (scope, selector) => all(selector, scope);\n\n    var TagBoundaries = [\n        'body',\n        'p',\n        'div',\n        'article',\n        'aside',\n        'figcaption',\n        'figure',\n        'footer',\n        'header',\n        'nav',\n        'section',\n        'ol',\n        'ul',\n        'li',\n        'table',\n        'thead',\n        'tbody',\n        'tfoot',\n        'caption',\n        'tr',\n        'td',\n        'th',\n        'h1',\n        'h2',\n        'h3',\n        'h4',\n        'h5',\n        'h6',\n        'blockquote',\n        'pre',\n        'address'\n    ];\n\n    var DomUniverse = () => {\n        const clone$1 = (element) => {\n            return SugarElement.fromDom(element.dom.cloneNode(false));\n        };\n        const document = (element) => documentOrOwner(element).dom;\n        const isBoundary = (element) => {\n            if (!isElement(element)) {\n                return false;\n            }\n            if (name(element) === 'body') {\n                return true;\n            }\n            return contains(TagBoundaries, name(element));\n        };\n        const isEmptyTag = (element) => {\n            if (!isElement(element)) {\n                return false;\n            }\n            return contains(['br', 'img', 'hr', 'input'], name(element));\n        };\n        const isNonEditable = (element) => isElement(element) && get$2(element, 'contenteditable') === 'false';\n        const comparePosition = (element, other) => {\n            return element.dom.compareDocumentPosition(other.dom);\n        };\n        const copyAttributesTo = (source, destination) => {\n            const as = clone(source);\n            setAll(destination, as);\n        };\n        const isSpecial = (element) => {\n            const tag = name(element);\n            return contains([\n                'script', 'noscript', 'iframe', 'noframes', 'noembed', 'title', 'style', 'textarea', 'xmp'\n            ], tag);\n        };\n        const getLanguage = (element) => isElement(element) ? getOpt(element, 'lang') : Optional.none();\n        return {\n            up: constant({\n                selector: ancestor,\n                closest: closest,\n                predicate: ancestor$1,\n                all: parents\n            }),\n            down: constant({\n                selector: descendants,\n                predicate: descendants$1\n            }),\n            styles: constant({\n                get: get$1,\n                getRaw: getRaw,\n                set: set$1,\n                remove: remove\n            }),\n            attrs: constant({\n                get: get$2,\n                set: set$2,\n                remove: remove$2,\n                copyTo: copyAttributesTo\n            }),\n            insert: constant({\n                before: before,\n                after: after$1,\n                afterAll: after,\n                append: append$1,\n                appendAll: append,\n                prepend: prepend,\n                wrap: wrap\n            }),\n            remove: constant({\n                unwrap: unwrap,\n                remove: remove$1\n            }),\n            create: constant({\n                nu: SugarElement.fromTag,\n                clone: clone$1,\n                text: SugarElement.fromText\n            }),\n            query: constant({\n                comparePosition,\n                prevSibling: prevSibling,\n                nextSibling: nextSibling\n            }),\n            property: constant({\n                children: children,\n                name: name,\n                parent: parent,\n                document,\n                isText: isText,\n                isComment: isComment,\n                isElement: isElement,\n                isSpecial,\n                getLanguage,\n                getText: get,\n                setText: set,\n                isBoundary,\n                isEmptyTag,\n                isNonEditable\n            }),\n            eq: eq,\n            is: is\n        };\n    };\n\n    const scan = (universe, element, direction) => {\n        // if a comment or zero-length text, scan the siblings\n        if ((universe.property().isText(element) && universe.property().getText(element).trim().length === 0)\n            || universe.property().isComment(element)) {\n            return direction(element).bind((elem) => {\n                return scan(universe, elem, direction).orThunk(() => {\n                    return Optional.some(elem);\n                });\n            });\n        }\n        else {\n            return Optional.none();\n        }\n    };\n    const toEnd = (universe, element) => {\n        if (universe.property().isText(element)) {\n            return universe.property().getText(element).length;\n        }\n        const children = universe.property().children(element);\n        return children.length;\n    };\n    const freefallRtl$2 = (universe, element) => {\n        const candidate = scan(universe, element, universe.query().prevSibling).getOr(element);\n        if (universe.property().isText(candidate)) {\n            return point(candidate, toEnd(universe, candidate));\n        }\n        const children = universe.property().children(candidate);\n        return children.length > 0 ? freefallRtl$2(universe, children[children.length - 1]) : point(candidate, toEnd(universe, candidate));\n    };\n\n    const freefallRtl$1 = freefallRtl$2;\n\n    const universe = DomUniverse();\n    const freefallRtl = (element) => {\n        return freefallRtl$1(universe, element);\n    };\n\n    const fireToggleAccordionEvent = (editor, element, state) => editor.dispatch('ToggledAccordion', { element, state });\n    const fireToggleAllAccordionsEvent = (editor, elements, state) => editor.dispatch('ToggledAllAccordions', { elements, state });\n\n    const accordionTag = 'details';\n    const accordionDetailsClass = 'mce-accordion';\n    const accordionSummaryClass = 'mce-accordion-summary';\n    const accordionBodyWrapperClass = 'mce-accordion-body';\n    const accordionBodyWrapperTag = 'div';\n\n    var global$3 = tinymce.util.Tools.resolve('tinymce.util.Tools');\n\n    const isSummary = (node) => (node === null || node === void 0 ? void 0 : node.nodeName) === 'SUMMARY';\n    const isDetails = (node) => (node === null || node === void 0 ? void 0 : node.nodeName) === 'DETAILS';\n    const isOpen = (details) => details.hasAttribute('open');\n    const isInSummary = (editor) => {\n        const node = editor.selection.getNode();\n        return isSummary(node) || Boolean(editor.dom.getParent(node, isSummary));\n    };\n    const isAtDetailsStart = (editor) => {\n        const rng = editor.selection.getRng();\n        return isDetails(rng.startContainer)\n            && rng.collapsed\n            && rng.startOffset === 0;\n    };\n    const isInsertAllowed = (editor) => !isInSummary(editor) && editor.dom.isEditable(editor.selection.getNode()) && !editor.mode.isReadOnly();\n    const getSelectedDetails = (editor) => Optional.from(editor.dom.getParent(editor.selection.getNode(), isDetails));\n    const isDetailsSelected = (editor) => getSelectedDetails(editor).isSome();\n    const insertBogus = (element) => {\n        element.innerHTML = '<br data-mce-bogus=\"1\" />';\n        return element;\n    };\n    const createParagraph = (editor) => insertBogus(editor.dom.create('p'));\n    const createSummary = (editor) => insertBogus(editor.dom.create('summary'));\n    const insertAndSelectParagraphAfter = (editor, target) => {\n        const paragraph = createParagraph(editor);\n        target.insertAdjacentElement('afterend', paragraph);\n        editor.selection.setCursorLocation(paragraph, 0);\n    };\n    const normalizeContent = (editor, accordion) => {\n        if (isSummary(accordion === null || accordion === void 0 ? void 0 : accordion.lastChild)) {\n            const paragraph = createParagraph(editor);\n            accordion.appendChild(paragraph);\n            editor.selection.setCursorLocation(paragraph, 0);\n        }\n    };\n    const normalizeSummary = (editor, accordion) => {\n        if (!isSummary(accordion === null || accordion === void 0 ? void 0 : accordion.firstChild)) {\n            const summary = createSummary(editor);\n            accordion.prepend(summary);\n            editor.selection.setCursorLocation(summary, 0);\n        }\n    };\n    const normalizeAccordion = (editor) => (accordion) => {\n        normalizeContent(editor, accordion);\n        normalizeSummary(editor, accordion);\n    };\n    const normalizeDetails = (editor) => {\n        global$3.each(global$3.grep(editor.dom.select('details', editor.getBody())), normalizeAccordion(editor));\n    };\n\n    const insertAccordion = (editor) => {\n        if (!isInsertAllowed(editor)) {\n            return;\n        }\n        const editorBody = SugarElement.fromDom(editor.getBody());\n        const uid = generate('acc');\n        const summaryText = editor.dom.encode(editor.selection.getRng().toString() || editor.translate('Accordion summary...'));\n        const bodyText = editor.dom.encode(editor.translate('Accordion body...'));\n        const accordionSummaryHtml = `<summary class=\"${accordionSummaryClass}\">${summaryText}</summary>`;\n        const accordionBodyHtml = `<${accordionBodyWrapperTag} class=\"${accordionBodyWrapperClass}\"><p>${bodyText}</p></${accordionBodyWrapperTag}>`;\n        editor.undoManager.transact(() => {\n            editor.insertContent([\n                `<details data-mce-id=\"${uid}\" class=\"${accordionDetailsClass}\" open=\"open\">`,\n                accordionSummaryHtml,\n                accordionBodyHtml,\n                `</details>`\n            ].join(''));\n            descendant(editorBody, `[data-mce-id=\"${uid}\"]`).each((detailsElm) => {\n                remove$2(detailsElm, 'data-mce-id');\n                descendant(detailsElm, `summary`).each((summaryElm) => {\n                    // Set the cursor location to be at the end of the summary text\n                    const rng = editor.dom.createRng();\n                    const des = freefallRtl(summaryElm);\n                    rng.setStart(des.element.dom, des.offset);\n                    rng.setEnd(des.element.dom, des.offset);\n                    editor.selection.setRng(rng);\n                });\n            });\n        });\n    };\n    const toggleDetailsElement = (details, state) => {\n        const shouldOpen = state !== null && state !== void 0 ? state : !isOpen(details);\n        if (shouldOpen) {\n            details.setAttribute('open', 'open');\n        }\n        else {\n            details.removeAttribute('open');\n        }\n        return shouldOpen;\n    };\n    const toggleAccordion = (editor, state) => {\n        getSelectedDetails(editor).each((details) => {\n            fireToggleAccordionEvent(editor, details, toggleDetailsElement(details, state));\n        });\n    };\n    const removeAccordion = (editor) => {\n        if (!editor.mode.isReadOnly()) {\n            getSelectedDetails(editor)\n                .each((details) => {\n                const { nextSibling } = details;\n                if (nextSibling) {\n                    editor.selection.select(nextSibling, true);\n                    editor.selection.collapse(true);\n                }\n                else {\n                    insertAndSelectParagraphAfter(editor, details);\n                }\n                details.remove();\n            });\n        }\n    };\n    const toggleAllAccordions = (editor, state) => {\n        const accordions = Array.from(editor.getBody().querySelectorAll('details'));\n        if (accordions.length === 0) {\n            return;\n        }\n        each$1(accordions, (accordion) => toggleDetailsElement(accordion, state !== null && state !== void 0 ? state : !isOpen(accordion)));\n        fireToggleAllAccordionsEvent(editor, accordions, state);\n    };\n\n    const register$1 = (editor) => {\n        editor.addCommand('InsertAccordion', () => insertAccordion(editor));\n        editor.addCommand('ToggleAccordion', (_ui, value) => toggleAccordion(editor, value));\n        editor.addCommand('ToggleAllAccordions', (_ui, value) => toggleAllAccordions(editor, value));\n        editor.addCommand('RemoveAccordion', () => removeAccordion(editor));\n    };\n\n    var global$2 = tinymce.util.Tools.resolve('tinymce.html.Node');\n\n    const getClassList = (node) => { var _a, _b; return (_b = (_a = node.attr('class')) === null || _a === void 0 ? void 0 : _a.split(' ')) !== null && _b !== void 0 ? _b : []; };\n    const addClasses = (node, classes) => {\n        const classListSet = new Set([...getClassList(node), ...classes]);\n        const newClassList = Array.from(classListSet);\n        if (newClassList.length > 0) {\n            node.attr('class', newClassList.join(' '));\n        }\n    };\n    const removeClasses = (node, classes) => {\n        const newClassList = filter(getClassList(node), (clazz) => !classes.has(clazz));\n        node.attr('class', newClassList.length > 0 ? newClassList.join(' ') : null);\n    };\n    const isAccordionDetailsNode = (node) => node.name === accordionTag && contains(getClassList(node), accordionDetailsClass);\n    const isAccordionBodyWrapperNode = (node) => node.name === accordionBodyWrapperTag && contains(getClassList(node), accordionBodyWrapperClass);\n    const getAccordionChildren = (accordionNode) => {\n        const children = accordionNode.children();\n        let summaryNode;\n        let wrapperNode;\n        const otherNodes = [];\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            // Only want to get the first summary element\n            if (child.name === 'summary' && isNullable(summaryNode)) {\n                summaryNode = child;\n            }\n            else if (isAccordionBodyWrapperNode(child) && isNullable(wrapperNode)) {\n                wrapperNode = child;\n            }\n            else {\n                otherNodes.push(child);\n            }\n        }\n        return {\n            summaryNode,\n            wrapperNode,\n            otherNodes\n        };\n    };\n    const padInputNode = (node) => {\n        // Add br to node to ensure the cursor can be placed inside the node\n        // Mark as bogus so that it is converted to an nbsp on serialization\n        const br = new global$2('br', 1);\n        br.attr('data-mce-bogus', '1');\n        node.empty();\n        node.append(br);\n    };\n    const setup$2 = (editor) => {\n        editor.on('PreInit', () => {\n            const { serializer, parser } = editor;\n            // Purpose:\n            // - add mce-accordion-summary class to summary node\n            // - wrap details body in div and add mce-accordion-body class (TINY-9959 assists with Chrome selection issue)\n            parser.addNodeFilter(accordionTag, (nodes) => {\n                // Using a traditional for loop here as we may have to iterate over many nodes and it is the most performant way of doing so\n                for (let i = 0; i < nodes.length; i++) {\n                    const node = nodes[i];\n                    if (isAccordionDetailsNode(node)) {\n                        const accordionNode = node;\n                        const { summaryNode, wrapperNode, otherNodes } = getAccordionChildren(accordionNode);\n                        const hasSummaryNode = isNonNullable(summaryNode);\n                        const newSummaryNode = hasSummaryNode ? summaryNode : new global$2('summary', 1);\n                        // If there is nothing in the summary, pad it with a br\n                        // so the cursor can be put inside the accordion summary\n                        if (isNullable(newSummaryNode.firstChild)) {\n                            padInputNode(newSummaryNode);\n                        }\n                        addClasses(newSummaryNode, [accordionSummaryClass]);\n                        if (!hasSummaryNode) {\n                            if (isNonNullable(accordionNode.firstChild)) {\n                                accordionNode.insert(newSummaryNode, accordionNode.firstChild, true);\n                            }\n                            else {\n                                accordionNode.append(newSummaryNode);\n                            }\n                        }\n                        const hasWrapperNode = isNonNullable(wrapperNode);\n                        const newWrapperNode = hasWrapperNode ? wrapperNode : new global$2(accordionBodyWrapperTag, 1);\n                        newWrapperNode.attr('data-mce-bogus', '1');\n                        addClasses(newWrapperNode, [accordionBodyWrapperClass]);\n                        if (otherNodes.length > 0) {\n                            for (let j = 0; j < otherNodes.length; j++) {\n                                const otherNode = otherNodes[j];\n                                newWrapperNode.append(otherNode);\n                            }\n                        }\n                        // If there is nothing in the wrapper, append a placeholder p tag\n                        // so the cursor can be put inside the accordion body\n                        if (isNullable(newWrapperNode.firstChild)) {\n                            const pNode = new global$2('p', 1);\n                            padInputNode(pNode);\n                            newWrapperNode.append(pNode);\n                        }\n                        if (!hasWrapperNode) {\n                            accordionNode.append(newWrapperNode);\n                        }\n                    }\n                }\n            });\n            // Purpose:\n            // - remove div wrapping details content as it is only required during editor (see TINY-9959 for details)\n            // - remove mce-accordion-summary class on the summary node\n            serializer.addNodeFilter(accordionTag, (nodes) => {\n                const summaryClassRemoveSet = new Set([accordionSummaryClass]);\n                // Using a traditional for loop here as we may have to iterate over many nodes and it is the most performant way of doing so\n                for (let i = 0; i < nodes.length; i++) {\n                    const node = nodes[i];\n                    if (isAccordionDetailsNode(node)) {\n                        const accordionNode = node;\n                        const { summaryNode, wrapperNode } = getAccordionChildren(accordionNode);\n                        if (isNonNullable(summaryNode)) {\n                            removeClasses(summaryNode, summaryClassRemoveSet);\n                        }\n                        if (isNonNullable(wrapperNode)) {\n                            wrapperNode.unwrap();\n                        }\n                    }\n                }\n            });\n        });\n    };\n\n    var global$1 = tinymce.util.Tools.resolve('tinymce.util.VK');\n\n    const setupEnterKeyInSummary = (editor) => {\n        editor.on('keydown', (event) => {\n            if (!event.shiftKey && event.keyCode === global$1.ENTER\n                && isInSummary(editor) || isAtDetailsStart(editor)) {\n                event.preventDefault();\n                editor.execCommand('ToggleAccordion');\n            }\n        });\n    };\n    const setup$1 = (editor) => {\n        setupEnterKeyInSummary(editor);\n        editor.on('ExecCommand', (e) => {\n            const cmd = e.command.toLowerCase();\n            if ((cmd === 'delete' || cmd === 'forwarddelete') && isDetailsSelected(editor)) {\n                normalizeDetails(editor);\n            }\n        });\n    };\n\n    var global = tinymce.util.Tools.resolve('tinymce.Env');\n\n    const setup = (editor) => {\n        // TINY-10177: On Safari, clicking on the expand arrow of the `details` element sets the selection before the `summary`,\n        // so we override the selection to the beginning of `summary` content\n        if (global.browser.isSafari()) {\n            editor.on('click', (e) => {\n                if (isSummary(e.target)) {\n                    const summary = e.target;\n                    const rng = editor.selection.getRng();\n                    if (rng.collapsed && rng.startContainer === summary.parentNode && rng.startOffset === 0) {\n                        editor.selection.setCursorLocation(summary, 0);\n                    }\n                }\n            });\n        }\n    };\n\n    const onSetup = (editor) => (buttonApi) => {\n        const onNodeChange = () => buttonApi.setEnabled(isInsertAllowed(editor));\n        editor.on('NodeChange', onNodeChange);\n        return () => editor.off('NodeChange', onNodeChange);\n    };\n    const register = (editor) => {\n        const onAction = () => editor.execCommand('InsertAccordion');\n        editor.ui.registry.addButton('accordion', { icon: 'accordion', tooltip: 'Insert accordion', onSetup: onSetup(editor), onAction });\n        editor.ui.registry.addMenuItem('accordion', { icon: 'accordion', text: 'Accordion', onSetup: onSetup(editor), onAction });\n        editor.ui.registry.addToggleButton('accordiontoggle', {\n            icon: 'accordion-toggle',\n            tooltip: 'Toggle accordion',\n            onAction: () => editor.execCommand('ToggleAccordion')\n        });\n        editor.ui.registry.addToggleButton('accordionremove', {\n            icon: 'remove',\n            tooltip: 'Delete accordion',\n            onAction: () => editor.execCommand('RemoveAccordion')\n        });\n        editor.ui.registry.addContextToolbar('accordion', {\n            predicate: (accordion) => editor.dom.is(accordion, 'details') && editor.getBody().contains(accordion) && editor.dom.isEditable(accordion.parentNode),\n            items: 'accordiontoggle accordionremove',\n            scope: 'node',\n            position: 'node'\n        });\n    };\n\n    var Plugin = () => {\n        global$4.add('accordion', (editor) => {\n            register(editor);\n            register$1(editor);\n            setup$1(editor);\n            setup$2(editor);\n            setup(editor);\n        });\n    };\n\n    Plugin();\n    /** *****\n     * DO NOT EXPORT ANYTHING\n     *\n     * IF YOU DO ROLLUP WILL LEAVE A GLOBAL ON THE PAGE\n     *******/\n\n})();\n"],"names":["global$4","tinymce","util","Tools","resolve","isSimpleType","type","value","isString","x","t","Array","isArray","o","v","proto","constructor","String","prototype","isPrototypeOf","_a","name","typeOf","isType$1","isBoolean","isNullable","a","isNonNullable","isFunction","isNumber","constant","tripleEquals","b","never","Optional","tag","this","some","none","singletonNone","fold","onNone","onSome","isSome","isNone","map","mapper","bind","binder","exists","predicate","forall","filter","getOr","replacement","or","getOrThunk","thunk","orThunk","getOrDie","message","Error","from","getOrNull","getOrUndefined","each","worker","toArray","toString","nativeIndexOf","indexOf","contains","xs","rawIndexOf","ts","call","f","len","length","r","i","each$1","keys","Object","unique","generate","prefix","time","Date","getTime","random$1","Math","floor","window","crypto","getRandomValues","Uint32Array","trim","s","replace","point","element","offset","fromDom","node","dom","SugarElement","fromHtml","html","scope","div","document","createElement","innerHTML","hasChildNodes","childNodes","console","error","fromTag","fromText","text","createTextNode","fromPoint","docElm","y","elementFromPoint","is$1","selector","nodeType","elem","undefined","matches","msMatchesSelector","webkitMatchesSelector","mozMatchesSelector","bypassSelector","childElementCount","eq","e1","e2","is","nodeName","toLowerCase","isType","isComment","isElement","isText","isDocument","isDocumentFragment","documentOrOwner","dos","ownerDocument","parent","parentNode","parents","isRoot","stop","ret","rawParent","p","push","prevSibling","previousSibling","nextSibling","children","firstChild","index","cs","child","getShadowRoot","e","getRootNode","host","getShadowHost","before","marker","insertBefore","after$1","append$1","prepend","appendChild","wrap","wrapper","after","elements","append","rawSet","key","setAttribute","set$2","setAll","attrs","obj","props","k","get$2","getAttribute","getOpt","remove$2","removeAttribute","clone","foldl","attributes","acc","attr","remove$1","removeChild","unwrap","children$1","isSupported","style","getPropertyValue","inBody","doc","body","fbc","fab","set$1","property","setProperty","internalSet","get$1","getComputedStyle","getUnsafeProperty","getRaw","raw","remove","removeProperty","internalRemove","lhs","rhs","comparator","left","is$2","api","getOption","nodeValue","get","set","NodeValue","ancestor$1","el","ancestor","descendant","base","querySelector","one","closest","ClosestOrAncestor","descendants$1","result","concat","descendants","querySelectorAll","all","TagBoundaries","scan","universe","direction","getText","toEnd","freefallRtl$2","candidate","query","freefallRtl$1","up","down","styles","copyTo","source","destination","as","insert","afterAll","appendAll","create","nu","cloneNode","comparePosition","other","compareDocumentPosition","isSpecial","getLanguage","setText","isBoundary","isEmptyTag","isNonEditable","accordionTag","accordionDetailsClass","accordionSummaryClass","accordionBodyWrapperClass","accordionBodyWrapperTag","global$3","isSummary","isDetails","isOpen","details","hasAttribute","isInSummary","editor","selection","getNode","Boolean","getParent","isInsertAllowed","isEditable","mode","isReadOnly","getSelectedDetails","insertBogus","createParagraph","normalizeSummary","accordion","summary","createSummary","setCursorLocation","normalizeAccordion","lastChild","paragraph","normalizeContent","insertAccordion","editorBody","getBody","uid","summaryText","encode","getRng","translate","bodyText","accordionSummaryHtml","accordionBodyHtml","undoManager","transact","insertContent","join","detailsElm","summaryElm","rng","createRng","des","setStart","setEnd","setRng","toggleDetailsElement","state","shouldOpen","removeAccordion","select","collapse","target","insertAdjacentElement","insertAndSelectParagraphAfter","register$1","addCommand","_ui","dispatch","fireToggleAccordionEvent","toggleAccordion","accordions","fireToggleAllAccordionsEvent","toggleAllAccordions","global$2","getClassList","_b","split","addClasses","classes","classListSet","Set","newClassList","removeClasses","pred","clazz","has","isAccordionDetailsNode","isAccordionBodyWrapperNode","getAccordionChildren","accordionNode","summaryNode","wrapperNode","otherNodes","padInputNode","br","empty","global$1","setupEnterKeyInSummary","on","event","shiftKey","keyCode","ENTER","startContainer","collapsed","startOffset","isAtDetailsStart","preventDefault","execCommand","setup$1","cmd","command","isDetailsSelected","grep","normalizeDetails","global","onSetup","buttonApi","onNodeChange","setEnabled","off","add","onAction","ui","registry","addButton","icon","tooltip","addMenuItem","addToggleButton","addContextToolbar","items","position","register","serializer","parser","addNodeFilter","nodes","hasSummaryNode","newSummaryNode","hasWrapperNode","newWrapperNode","j","otherNode","pNode","summaryClassRemoveSet","setup$2","browser","isSafari","setup"],"sourceRoot":""}