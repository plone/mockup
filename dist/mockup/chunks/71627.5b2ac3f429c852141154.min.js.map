{"version":3,"file":"chunks/71627.5b2ac3f429c852141154.min.js","mappings":"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","sources":["webpack://@plone/mockup/./node_modules/tinymce/plugins/advlist/plugin.js","webpack://@plone/mockup/./node_modules/tinymce/plugins/advlist/index.js"],"sourcesContent":["/**\n * TinyMCE version 8.3.1 (2025-12-17)\n */\n\n(function () {\n    'use strict';\n\n    var global$1 = tinymce.util.Tools.resolve('tinymce.PluginManager');\n\n    const applyListFormat = (editor, listName, styleValue) => {\n        const cmd = listName === 'UL' ? 'InsertUnorderedList' : 'InsertOrderedList';\n        editor.execCommand(cmd, false, styleValue === false ? null : { 'list-style-type': styleValue });\n    };\n\n    const register$2 = (editor) => {\n        editor.addCommand('ApplyUnorderedListStyle', (ui, value) => {\n            applyListFormat(editor, 'UL', value['list-style-type']);\n        });\n        editor.addCommand('ApplyOrderedListStyle', (ui, value) => {\n            applyListFormat(editor, 'OL', value['list-style-type']);\n        });\n    };\n\n    const option = (name) => (editor) => editor.options.get(name);\n    const register$1 = (editor) => {\n        const registerOption = editor.options.register;\n        registerOption('advlist_number_styles', {\n            processor: 'string[]',\n            default: 'default,lower-alpha,lower-greek,lower-roman,upper-alpha,upper-roman'.split(',')\n        });\n        registerOption('advlist_bullet_styles', {\n            processor: 'string[]',\n            default: 'default,disc,circle,square'.split(',')\n        });\n    };\n    const getNumberStyles = option('advlist_number_styles');\n    const getBulletStyles = option('advlist_bullet_styles');\n\n    /* eslint-disable @typescript-eslint/no-wrapper-object-types */\n    const isNullable = (a) => a === null || a === undefined;\n    const isNonNullable = (a) => !isNullable(a);\n\n    /**\n     * The `Optional` type represents a value (of any type) that potentially does\n     * not exist. Any `Optional<T>` can either be a `Some<T>` (in which case the\n     * value does exist) or a `None` (in which case the value does not exist). This\n     * module defines a whole lot of FP-inspired utility functions for dealing with\n     * `Optional` objects.\n     *\n     * Comparison with null or undefined:\n     * - We don't get fancy null coalescing operators with `Optional`\n     * - We do get fancy helper functions with `Optional`\n     * - `Optional` support nesting, and allow for the type to still be nullable (or\n     * another `Optional`)\n     * - There is no option to turn off strict-optional-checks like there is for\n     * strict-null-checks\n     */\n    class Optional {\n        tag;\n        value;\n        // Sneaky optimisation: every instance of Optional.none is identical, so just\n        // reuse the same object\n        static singletonNone = new Optional(false);\n        // The internal representation has a `tag` and a `value`, but both are\n        // private: able to be console.logged, but not able to be accessed by code\n        constructor(tag, value) {\n            this.tag = tag;\n            this.value = value;\n        }\n        // --- Identities ---\n        /**\n         * Creates a new `Optional<T>` that **does** contain a value.\n         */\n        static some(value) {\n            return new Optional(true, value);\n        }\n        /**\n         * Create a new `Optional<T>` that **does not** contain a value. `T` can be\n         * any type because we don't actually have a `T`.\n         */\n        static none() {\n            return Optional.singletonNone;\n        }\n        /**\n         * Perform a transform on an `Optional` type. Regardless of whether this\n         * `Optional` contains a value or not, `fold` will return a value of type `U`.\n         * If this `Optional` does not contain a value, the `U` will be created by\n         * calling `onNone`. If this `Optional` does contain a value, the `U` will be\n         * created by calling `onSome`.\n         *\n         * For the FP enthusiasts in the room, this function:\n         * 1. Could be used to implement all of the functions below\n         * 2. Forms a catamorphism\n         */\n        fold(onNone, onSome) {\n            if (this.tag) {\n                return onSome(this.value);\n            }\n            else {\n                return onNone();\n            }\n        }\n        /**\n         * Determine if this `Optional` object contains a value.\n         */\n        isSome() {\n            return this.tag;\n        }\n        /**\n         * Determine if this `Optional` object **does not** contain a value.\n         */\n        isNone() {\n            return !this.tag;\n        }\n        // --- Functor (name stolen from Haskell / maths) ---\n        /**\n         * Perform a transform on an `Optional` object, **if** there is a value. If\n         * you provide a function to turn a T into a U, this is the function you use\n         * to turn an `Optional<T>` into an `Optional<U>`. If this **does** contain\n         * a value then the output will also contain a value (that value being the\n         * output of `mapper(this.value)`), and if this **does not** contain a value\n         * then neither will the output.\n         */\n        map(mapper) {\n            if (this.tag) {\n                return Optional.some(mapper(this.value));\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Monad (name stolen from Haskell / maths) ---\n        /**\n         * Perform a transform on an `Optional` object, **if** there is a value.\n         * Unlike `map`, here the transform itself also returns an `Optional`.\n         */\n        bind(binder) {\n            if (this.tag) {\n                return binder(this.value);\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Traversable (name stolen from Haskell / maths) ---\n        /**\n         * For a given predicate, this function finds out if there **exists** a value\n         * inside this `Optional` object that meets the predicate. In practice, this\n         * means that for `Optional`s that do not contain a value it returns false (as\n         * no predicate-meeting value exists).\n         */\n        exists(predicate) {\n            return this.tag && predicate(this.value);\n        }\n        /**\n         * For a given predicate, this function finds out if **all** the values inside\n         * this `Optional` object meet the predicate. In practice, this means that\n         * for `Optional`s that do not contain a value it returns true (as all 0\n         * objects do meet the predicate).\n         */\n        forall(predicate) {\n            return !this.tag || predicate(this.value);\n        }\n        filter(predicate) {\n            if (!this.tag || predicate(this.value)) {\n                return this;\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Getters ---\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value.\n         */\n        getOr(replacement) {\n            return this.tag ? this.value : replacement;\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value.  Unlike `getOr`, in this method the `replacement` object is also\n         * `Optional` - meaning that this method will always return an `Optional`.\n         */\n        or(replacement) {\n            return this.tag ? this : replacement;\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value. Unlike `getOr`, in this method the `replacement` value is\n         * \"thunked\" - that is to say that you don't pass a value to `getOrThunk`, you\n         * pass a function which (if called) will **return** the `value` you want to\n         * use.\n         */\n        getOrThunk(thunk) {\n            return this.tag ? this.value : thunk();\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided Optional object does not contain a\n         * value.\n         *\n         * Unlike `or`, in this method the `replacement` value is \"thunked\" - that is\n         * to say that you don't pass a value to `orThunk`, you pass a function which\n         * (if called) will **return** the `value` you want to use.\n         *\n         * Unlike `getOrThunk`, in this method the `replacement` value is also\n         * `Optional`, meaning that this method will always return an `Optional`.\n         */\n        orThunk(thunk) {\n            return this.tag ? this : thunk();\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, throwing an\n         * exception if the provided `Optional` object does not contain a value.\n         *\n         * WARNING:\n         * You should only be using this function if you know that the `Optional`\n         * object **is not** empty (otherwise you're throwing exceptions in production\n         * code, which is bad).\n         *\n         * In tests this is more acceptable.\n         *\n         * Prefer other methods to this, such as `.each`.\n         */\n        getOrDie(message) {\n            if (!this.tag) {\n                throw new Error(message ?? 'Called getOrDie on None');\n            }\n            else {\n                return this.value;\n            }\n        }\n        // --- Interop with null and undefined ---\n        /**\n         * Creates an `Optional` value from a nullable (or undefined-able) input.\n         * Null, or undefined, is converted to `None`, and anything else is converted\n         * to `Some`.\n         */\n        static from(value) {\n            return isNonNullable(value) ? Optional.some(value) : Optional.none();\n        }\n        /**\n         * Converts an `Optional` to a nullable type, by getting the value if it\n         * exists, or returning `null` if it does not.\n         */\n        getOrNull() {\n            return this.tag ? this.value : null;\n        }\n        /**\n         * Converts an `Optional` to an undefined-able type, by getting the value if\n         * it exists, or returning `undefined` if it does not.\n         */\n        getOrUndefined() {\n            return this.value;\n        }\n        // --- Utilities ---\n        /**\n         * If the `Optional` contains a value, perform an action on that value.\n         * Unlike the rest of the methods on this type, `.each` has side-effects. If\n         * you want to transform an `Optional<T>` **into** something, then this is not\n         * the method for you. If you want to use an `Optional<T>` to **do**\n         * something, then this is the method for you - provided you're okay with not\n         * doing anything in the case where the `Optional` doesn't have a value inside\n         * it. If you're not sure whether your use-case fits into transforming\n         * **into** something or **doing** something, check whether it has a return\n         * value. If it does, you should be performing a transform.\n         */\n        each(worker) {\n            if (this.tag) {\n                worker(this.value);\n            }\n        }\n        /**\n         * Turn the `Optional` object into an array that contains all of the values\n         * stored inside the `Optional`. In practice, this means the output will have\n         * either 0 or 1 elements.\n         */\n        toArray() {\n            return this.tag ? [this.value] : [];\n        }\n        /**\n         * Turn the `Optional` object into a string for debugging or printing. Not\n         * recommended for production code, but good for debugging. Also note that\n         * these days an `Optional` object can be logged to the console directly, and\n         * its inner value (if it exists) will be visible.\n         */\n        toString() {\n            return this.tag ? `some(${this.value})` : 'none()';\n        }\n    }\n\n    const nativeIndexOf = Array.prototype.indexOf;\n    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);\n    const contains = (xs, x) => rawIndexOf(xs, x) > -1;\n    const findUntil = (xs, pred, until) => {\n        for (let i = 0, len = xs.length; i < len; i++) {\n            const x = xs[i];\n            if (pred(x, i)) {\n                return Optional.some(x);\n            }\n            else if (until(x, i)) {\n                break;\n            }\n        }\n        return Optional.none();\n    };\n\n    // There are many variations of Object iteration that are faster than the 'for-in' style:\n    // http://jsperf.com/object-keys-iteration/107\n    //\n    // Use the native keys if it is available (IE9+), otherwise fall back to manually filtering\n    const keys = Object.keys;\n    const each = (obj, f) => {\n        const props = keys(obj);\n        for (let k = 0, len = props.length; k < len; k++) {\n            const i = props[k];\n            const x = obj[i];\n            f(x, i);\n        }\n    };\n    const map = (obj, f) => {\n        return tupleMap(obj, (x, i) => ({\n            k: i,\n            v: f(x, i)\n        }));\n    };\n    const tupleMap = (obj, f) => {\n        const r = {};\n        each(obj, (x, i) => {\n            const tuple = f(x, i);\n            r[tuple.k] = tuple.v;\n        });\n        return r;\n    };\n\n    var global = tinymce.util.Tools.resolve('tinymce.util.Tools');\n\n    const isCustomList = (list) => /\\btox\\-/.test(list.className);\n    const isChildOfBody = (editor, elm) => {\n        return editor.dom.isChildOf(elm, editor.getBody());\n    };\n    const matchNodeNames = (regex) => (node) => isNonNullable(node) && regex.test(node.nodeName);\n    const isListNode = matchNodeNames(/^(OL|UL|DL)$/);\n    const isTableCellNode = matchNodeNames(/^(TH|TD)$/);\n    const inList = (editor, parents, nodeName) => findUntil(parents, (parent) => isListNode(parent) && !isCustomList(parent), isTableCellNode)\n        .exists((list) => list.nodeName === nodeName && isChildOfBody(editor, list));\n    const getSelectedStyleType = (editor) => {\n        const listElm = editor.dom.getParent(editor.selection.getNode(), 'ol,ul');\n        const style = editor.dom.getStyle(listElm, 'listStyleType');\n        return Optional.from(style);\n    };\n    // Lists/core/Util.ts - Duplicated in Lists plugin\n    const isWithinNonEditable = (editor, element) => element !== null && !editor.dom.isEditable(element);\n    const isWithinNonEditableList = (editor, element) => {\n        const parentList = editor.dom.getParent(element, 'ol,ul,dl');\n        return isWithinNonEditable(editor, parentList) || !editor.selection.isEditable();\n    };\n    const setNodeChangeHandler = (editor, nodeChangeHandler) => {\n        const initialNode = editor.selection.getNode();\n        // Set the initial state\n        nodeChangeHandler({\n            parents: editor.dom.getParents(initialNode),\n            element: initialNode\n        });\n        editor.on('NodeChange', nodeChangeHandler);\n        return () => editor.off('NodeChange', nodeChangeHandler);\n    };\n\n    // <ListStyles>\n    const styleValueToText = (styleValue) => {\n        return styleValue.replace(/\\-/g, ' ').replace(/\\b\\w/g, (chr) => {\n            return chr.toUpperCase();\n        });\n    };\n    const normalizeStyleValue = (styleValue) => isNullable(styleValue) || styleValue === 'default' ? '' : styleValue;\n    const makeSetupHandler = (editor, nodeName) => (api) => {\n        const updateButtonState = (editor, parents) => {\n            const element = editor.selection.getStart(true);\n            api.setActive(inList(editor, parents, nodeName));\n            api.setEnabled(!isWithinNonEditableList(editor, element));\n        };\n        const nodeChangeHandler = (e) => updateButtonState(editor, e.parents);\n        return setNodeChangeHandler(editor, nodeChangeHandler);\n    };\n    const addSplitButton = (editor, id, tooltip, cmd, nodeName, styles) => {\n        const listStyleTypeAliases = {\n            'lower-latin': 'lower-alpha',\n            'upper-latin': 'upper-alpha',\n            'lower-alpha': 'lower-latin',\n            'upper-alpha': 'upper-latin'\n        };\n        const stylesContainsAliasMap = map(listStyleTypeAliases, (alias) => contains(styles, alias));\n        editor.ui.registry.addSplitButton(id, {\n            tooltip,\n            chevronTooltip: tooltip,\n            icon: nodeName === \"OL\" /* ListType.OrderedList */ ? 'ordered-list' : 'unordered-list',\n            presets: 'listpreview',\n            columns: nodeName === \"OL\" /* ListType.OrderedList */ ? 3 : 4,\n            fetch: (callback) => {\n                const items = global.map(styles, (styleValue) => {\n                    const iconStyle = nodeName === \"OL\" /* ListType.OrderedList */ ? 'num' : 'bull';\n                    const iconName = styleValue === 'decimal' ? 'default' : styleValue;\n                    const itemValue = normalizeStyleValue(styleValue);\n                    const displayText = styleValueToText(styleValue);\n                    return {\n                        type: 'choiceitem',\n                        value: itemValue,\n                        icon: 'list-' + iconStyle + '-' + iconName,\n                        text: displayText\n                    };\n                });\n                callback(items);\n            },\n            onAction: () => editor.execCommand(cmd),\n            onItemAction: (_splitButtonApi, value) => {\n                applyListFormat(editor, nodeName, value);\n            },\n            select: (value) => {\n                const listStyleType = getSelectedStyleType(editor);\n                return listStyleType.exists((listStyle) => value === listStyle || (listStyleTypeAliases[listStyle] === value && !stylesContainsAliasMap[value]));\n            },\n            onSetup: makeSetupHandler(editor, nodeName)\n        });\n    };\n    const addButton = (editor, id, tooltip, cmd, nodeName, styleValue) => {\n        editor.ui.registry.addToggleButton(id, {\n            active: false,\n            tooltip,\n            icon: nodeName === \"OL\" /* ListType.OrderedList */ ? 'ordered-list' : 'unordered-list',\n            onSetup: makeSetupHandler(editor, nodeName),\n            // Need to make sure the button removes rather than applies if a list of the same type is selected\n            onAction: () => editor.queryCommandState(cmd) || styleValue === '' ? editor.execCommand(cmd) : applyListFormat(editor, nodeName, styleValue)\n        });\n    };\n    const addControl = (editor, id, tooltip, cmd, nodeName, styles) => {\n        if (styles.length > 1) {\n            addSplitButton(editor, id, tooltip, cmd, nodeName, styles);\n        }\n        else {\n            addButton(editor, id, tooltip, cmd, nodeName, normalizeStyleValue(styles[0]));\n        }\n    };\n    const register = (editor) => {\n        addControl(editor, 'numlist', 'Numbered list', 'InsertOrderedList', \"OL\" /* ListType.OrderedList */, getNumberStyles(editor));\n        addControl(editor, 'bullist', 'Bullet list', 'InsertUnorderedList', \"UL\" /* ListType.UnorderedList */, getBulletStyles(editor));\n    };\n\n    var Plugin = () => {\n        global$1.add('advlist', (editor) => {\n            if (editor.hasPlugin('lists')) {\n                register$1(editor);\n                register(editor);\n                register$2(editor);\n            }\n            else {\n                // eslint-disable-next-line no-console\n                console.error('Please use the Lists plugin together with the List Styles plugin.');\n            }\n        });\n    };\n\n    Plugin();\n    /** *****\n     * DO NOT EXPORT ANYTHING\n     *\n     * IF YOU DO ROLLUP WILL LEAVE A GLOBAL ON THE PAGE\n     *******/\n\n})();\n","// Exports the \"advlist\" plugin for usage with module loaders\n// Usage:\n//   CommonJS:\n//     require('tinymce/plugins/advlist')\n//   ES2015:\n//     import 'tinymce/plugins/advlist'\nrequire('./plugin.js');"],"names":["global$1","tinymce","util","Tools","resolve","applyListFormat","editor","listName","styleValue","cmd","execCommand","option","name","options","get","getNumberStyles","getBulletStyles","isNullable","a","isNonNullable","Optional","tag","value","static","constructor","this","some","none","singletonNone","fold","onNone","onSome","isSome","isNone","map","mapper","bind","binder","exists","predicate","forall","filter","getOr","replacement","or","getOrThunk","thunk","orThunk","getOrDie","message","Error","from","getOrNull","getOrUndefined","each","worker","toArray","toString","nativeIndexOf","Array","prototype","indexOf","contains","xs","x","rawIndexOf","ts","t","call","keys","Object","tupleMap","obj","f","r","props","k","len","length","i","tuple","v","global","matchNodeNames","regex","node","test","nodeName","isListNode","isTableCellNode","inList","parents","pred","until","findUntil","parent","className","list","elm","dom","isChildOf","getBody","isChildOfBody","normalizeStyleValue","makeSetupHandler","api","nodeChangeHandler","initialNode","selection","getNode","getParents","element","on","off","setNodeChangeHandler","e","getStart","setActive","setEnabled","parentList","getParent","isEditable","isWithinNonEditable","isWithinNonEditableList","updateButtonState","addSplitButton","id","tooltip","styles","listStyleTypeAliases","stylesContainsAliasMap","alias","ui","registry","chevronTooltip","icon","presets","columns","fetch","callback","iconStyle","iconName","itemValue","displayText","replace","chr","toUpperCase","styleValueToText","type","text","onAction","onItemAction","_splitButtonApi","select","listStyleType","listElm","style","getStyle","getSelectedStyleType","listStyle","onSetup","addControl","addToggleButton","active","queryCommandState","addButton","add","hasPlugin","registerOption","register","processor","default","split","register$1","addCommand","register$2","console","error"],"sourceRoot":""}