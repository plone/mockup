{"version":3,"file":"chunks/24303.4a7666f45b763b37570c.min.js","mappings":"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","sources":["webpack://@plone/mockup/./node_modules/tinymce/plugins/directionality/plugin.js"],"sourcesContent":["/**\n * TinyMCE version 7.2.1 (2024-07-03)\n */\n\n(function () {\n    'use strict';\n\n    var global = tinymce.util.Tools.resolve('tinymce.PluginManager');\n\n    const hasProto = (v, constructor, predicate) => {\n      var _a;\n      if (predicate(v, constructor.prototype)) {\n        return true;\n      } else {\n        return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n      }\n    };\n    const typeOf = x => {\n      const t = typeof x;\n      if (x === null) {\n        return 'null';\n      } else if (t === 'object' && Array.isArray(x)) {\n        return 'array';\n      } else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n        return 'string';\n      } else {\n        return t;\n      }\n    };\n    const isType$1 = type => value => typeOf(value) === type;\n    const isSimpleType = type => value => typeof value === type;\n    const isString = isType$1('string');\n    const isBoolean = isSimpleType('boolean');\n    const isNullable = a => a === null || a === undefined;\n    const isNonNullable = a => !isNullable(a);\n    const isFunction = isSimpleType('function');\n    const isNumber = isSimpleType('number');\n\n    const compose1 = (fbc, fab) => a => fbc(fab(a));\n    const constant = value => {\n      return () => {\n        return value;\n      };\n    };\n    const never = constant(false);\n\n    class Optional {\n      constructor(tag, value) {\n        this.tag = tag;\n        this.value = value;\n      }\n      static some(value) {\n        return new Optional(true, value);\n      }\n      static none() {\n        return Optional.singletonNone;\n      }\n      fold(onNone, onSome) {\n        if (this.tag) {\n          return onSome(this.value);\n        } else {\n          return onNone();\n        }\n      }\n      isSome() {\n        return this.tag;\n      }\n      isNone() {\n        return !this.tag;\n      }\n      map(mapper) {\n        if (this.tag) {\n          return Optional.some(mapper(this.value));\n        } else {\n          return Optional.none();\n        }\n      }\n      bind(binder) {\n        if (this.tag) {\n          return binder(this.value);\n        } else {\n          return Optional.none();\n        }\n      }\n      exists(predicate) {\n        return this.tag && predicate(this.value);\n      }\n      forall(predicate) {\n        return !this.tag || predicate(this.value);\n      }\n      filter(predicate) {\n        if (!this.tag || predicate(this.value)) {\n          return this;\n        } else {\n          return Optional.none();\n        }\n      }\n      getOr(replacement) {\n        return this.tag ? this.value : replacement;\n      }\n      or(replacement) {\n        return this.tag ? this : replacement;\n      }\n      getOrThunk(thunk) {\n        return this.tag ? this.value : thunk();\n      }\n      orThunk(thunk) {\n        return this.tag ? this : thunk();\n      }\n      getOrDie(message) {\n        if (!this.tag) {\n          throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n        } else {\n          return this.value;\n        }\n      }\n      static from(value) {\n        return isNonNullable(value) ? Optional.some(value) : Optional.none();\n      }\n      getOrNull() {\n        return this.tag ? this.value : null;\n      }\n      getOrUndefined() {\n        return this.value;\n      }\n      each(worker) {\n        if (this.tag) {\n          worker(this.value);\n        }\n      }\n      toArray() {\n        return this.tag ? [this.value] : [];\n      }\n      toString() {\n        return this.tag ? `some(${ this.value })` : 'none()';\n      }\n    }\n    Optional.singletonNone = new Optional(false);\n\n    const map = (xs, f) => {\n      const len = xs.length;\n      const r = new Array(len);\n      for (let i = 0; i < len; i++) {\n        const x = xs[i];\n        r[i] = f(x, i);\n      }\n      return r;\n    };\n    const each = (xs, f) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const filter = (xs, pred) => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n\n    const DOCUMENT = 9;\n    const DOCUMENT_FRAGMENT = 11;\n    const ELEMENT = 1;\n    const TEXT = 3;\n\n    const fromHtml = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      if (!div.hasChildNodes() || div.childNodes.length > 1) {\n        const message = 'HTML does not have a single root node';\n        console.error(message, html);\n        throw new Error(message);\n      }\n      return fromDom(div.childNodes[0]);\n    };\n    const fromTag = (tag, scope) => {\n      const doc = scope || document;\n      const node = doc.createElement(tag);\n      return fromDom(node);\n    };\n    const fromText = (text, scope) => {\n      const doc = scope || document;\n      const node = doc.createTextNode(text);\n      return fromDom(node);\n    };\n    const fromDom = node => {\n      if (node === null || node === undefined) {\n        throw new Error('Node cannot be null or undefined');\n      }\n      return { dom: node };\n    };\n    const fromPoint = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom);\n    const SugarElement = {\n      fromHtml,\n      fromTag,\n      fromText,\n      fromDom,\n      fromPoint\n    };\n\n    const is = (element, selector) => {\n      const dom = element.dom;\n      if (dom.nodeType !== ELEMENT) {\n        return false;\n      } else {\n        const elem = dom;\n        if (elem.matches !== undefined) {\n          return elem.matches(selector);\n        } else if (elem.msMatchesSelector !== undefined) {\n          return elem.msMatchesSelector(selector);\n        } else if (elem.webkitMatchesSelector !== undefined) {\n          return elem.webkitMatchesSelector(selector);\n        } else if (elem.mozMatchesSelector !== undefined) {\n          return elem.mozMatchesSelector(selector);\n        } else {\n          throw new Error('Browser lacks native selectors');\n        }\n      }\n    };\n\n    typeof window !== 'undefined' ? window : Function('return this;')();\n\n    const name = element => {\n      const r = element.dom.nodeName;\n      return r.toLowerCase();\n    };\n    const type = element => element.dom.nodeType;\n    const isType = t => element => type(element) === t;\n    const isElement = isType(ELEMENT);\n    const isText = isType(TEXT);\n    const isDocument = isType(DOCUMENT);\n    const isDocumentFragment = isType(DOCUMENT_FRAGMENT);\n    const isTag = tag => e => isElement(e) && name(e) === tag;\n\n    const owner = element => SugarElement.fromDom(element.dom.ownerDocument);\n    const documentOrOwner = dos => isDocument(dos) ? dos : owner(dos);\n    const parent = element => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n    const children$2 = element => map(element.dom.childNodes, SugarElement.fromDom);\n\n    const rawSet = (dom, key, value) => {\n      if (isString(value) || isBoolean(value) || isNumber(value)) {\n        dom.setAttribute(key, value + '');\n      } else {\n        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n        throw new Error('Attribute value was not simple');\n      }\n    };\n    const set = (element, key, value) => {\n      rawSet(element.dom, key, value);\n    };\n    const remove = (element, key) => {\n      element.dom.removeAttribute(key);\n    };\n\n    const isShadowRoot = dos => isDocumentFragment(dos) && isNonNullable(dos.dom.host);\n    const supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);\n    const getRootNode = supported ? e => SugarElement.fromDom(e.dom.getRootNode()) : documentOrOwner;\n    const getShadowRoot = e => {\n      const r = getRootNode(e);\n      return isShadowRoot(r) ? Optional.some(r) : Optional.none();\n    };\n    const getShadowHost = e => SugarElement.fromDom(e.dom.host);\n\n    const inBody = element => {\n      const dom = isText(element) ? element.dom.parentNode : element.dom;\n      if (dom === undefined || dom === null || dom.ownerDocument === null) {\n        return false;\n      }\n      const doc = dom.ownerDocument;\n      return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));\n    };\n\n    const ancestor$1 = (scope, predicate, isRoot) => {\n      let element = scope.dom;\n      const stop = isFunction(isRoot) ? isRoot : never;\n      while (element.parentNode) {\n        element = element.parentNode;\n        const el = SugarElement.fromDom(element);\n        if (predicate(el)) {\n          return Optional.some(el);\n        } else if (stop(el)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n\n    const ancestor = (scope, selector, isRoot) => ancestor$1(scope, e => is(e, selector), isRoot);\n\n    const isSupported = dom => dom.style !== undefined && isFunction(dom.style.getPropertyValue);\n\n    const get = (element, property) => {\n      const dom = element.dom;\n      const styles = window.getComputedStyle(dom);\n      const r = styles.getPropertyValue(property);\n      return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;\n    };\n    const getUnsafeProperty = (dom, property) => isSupported(dom) ? dom.style.getPropertyValue(property) : '';\n\n    const getDirection = element => get(element, 'direction') === 'rtl' ? 'rtl' : 'ltr';\n\n    const children$1 = (scope, predicate) => filter(children$2(scope), predicate);\n\n    const children = (scope, selector) => children$1(scope, e => is(e, selector));\n\n    const getParentElement = element => parent(element).filter(isElement);\n    const getNormalizedBlock = (element, isListItem) => {\n      const normalizedElement = isListItem ? ancestor(element, 'ol,ul') : Optional.some(element);\n      return normalizedElement.getOr(element);\n    };\n    const isListItem = isTag('li');\n    const setDirOnElements = (dom, blocks, dir) => {\n      each(blocks, block => {\n        const blockElement = SugarElement.fromDom(block);\n        const isBlockElementListItem = isListItem(blockElement);\n        const normalizedBlock = getNormalizedBlock(blockElement, isBlockElementListItem);\n        const normalizedBlockParent = getParentElement(normalizedBlock);\n        normalizedBlockParent.each(parent => {\n          dom.setStyle(normalizedBlock.dom, 'direction', null);\n          const parentDirection = getDirection(parent);\n          if (parentDirection === dir) {\n            remove(normalizedBlock, 'dir');\n          } else {\n            set(normalizedBlock, 'dir', dir);\n          }\n          if (getDirection(normalizedBlock) !== dir) {\n            dom.setStyle(normalizedBlock.dom, 'direction', dir);\n          }\n          if (isBlockElementListItem) {\n            const listItems = children(normalizedBlock, 'li[dir],li[style]');\n            each(listItems, listItem => {\n              remove(listItem, 'dir');\n              dom.setStyle(listItem.dom, 'direction', null);\n            });\n          }\n        });\n      });\n    };\n    const setDir = (editor, dir) => {\n      if (editor.selection.isEditable()) {\n        setDirOnElements(editor.dom, editor.selection.getSelectedBlocks(), dir);\n        editor.nodeChanged();\n      }\n    };\n\n    const register$1 = editor => {\n      editor.addCommand('mceDirectionLTR', () => {\n        setDir(editor, 'ltr');\n      });\n      editor.addCommand('mceDirectionRTL', () => {\n        setDir(editor, 'rtl');\n      });\n    };\n\n    const getNodeChangeHandler = (editor, dir) => api => {\n      const nodeChangeHandler = e => {\n        const element = SugarElement.fromDom(e.element);\n        api.setActive(getDirection(element) === dir);\n        api.setEnabled(editor.selection.isEditable());\n      };\n      editor.on('NodeChange', nodeChangeHandler);\n      api.setEnabled(editor.selection.isEditable());\n      return () => editor.off('NodeChange', nodeChangeHandler);\n    };\n    const register = editor => {\n      editor.ui.registry.addToggleButton('ltr', {\n        tooltip: 'Left to right',\n        icon: 'ltr',\n        onAction: () => editor.execCommand('mceDirectionLTR'),\n        onSetup: getNodeChangeHandler(editor, 'ltr')\n      });\n      editor.ui.registry.addToggleButton('rtl', {\n        tooltip: 'Right to left',\n        icon: 'rtl',\n        onAction: () => editor.execCommand('mceDirectionRTL'),\n        onSetup: getNodeChangeHandler(editor, 'rtl')\n      });\n    };\n\n    var Plugin = () => {\n      global.add('directionality', editor => {\n        register$1(editor);\n        register(editor);\n      });\n    };\n\n    Plugin();\n\n})();\n"],"names":["global","tinymce","util","Tools","resolve","isSimpleType","type","value","isString","x","t","Array","isArray","o","v","proto","constructor","String","prototype","isPrototypeOf","_a","name","typeOf","isType$1","isBoolean","isNonNullable","a","isNullable","isFunction","isNumber","never","Optional","tag","this","some","none","singletonNone","fold","onNone","onSome","isSome","isNone","map","mapper","bind","binder","exists","predicate","forall","filter","getOr","replacement","or","getOrThunk","thunk","orThunk","getOrDie","message","Error","from","getOrNull","getOrUndefined","each","worker","toArray","toString","xs","f","i","len","length","fromDom","node","dom","SugarElement","fromHtml","html","scope","div","document","createElement","innerHTML","hasChildNodes","childNodes","console","error","fromTag","fromText","text","createTextNode","fromPoint","docElm","y","elementFromPoint","is","element","selector","nodeType","elem","undefined","matches","msMatchesSelector","webkitMatchesSelector","mozMatchesSelector","window","Function","isType","isElement","isText","isDocument","isDocumentFragment","children$2","r","set","key","setAttribute","rawSet","remove","removeAttribute","getRootNode","Element","attachShadow","Node","e","dos","ownerDocument","getShadowRoot","host","getShadowHost","inBody","parentNode","doc","body","contains","fbc","fab","ancestor","isRoot","stop","el","ancestor$1","getUnsafeProperty","property","style","getPropertyValue","isSupported","getDirection","getComputedStyle","get","children","pred","push","children$1","getParentElement","parent","isListItem","nodeName","toLowerCase","setDirOnElements","blocks","dir","block","blockElement","isBlockElementListItem","normalizedBlock","getNormalizedBlock","setStyle","listItems","listItem","setDir","editor","selection","isEditable","getSelectedBlocks","nodeChanged","getNodeChangeHandler","api","nodeChangeHandler","setActive","setEnabled","on","off","add","addCommand","register$1","ui","registry","addToggleButton","tooltip","icon","onAction","execCommand","onSetup","register"],"sourceRoot":""}