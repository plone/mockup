{"version":3,"file":"chunks/19983.9ec527a98a59e28aa2bc.min.js","mappings":"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","sources":["webpack://@plone/mockup/./node_modules/codejar/codejar.js"],"sourcesContent":["const globalWindow = window;\nexport function CodeJar(editor, highlight, opt = {}) {\n    const options = Object.assign({ tab: '\\t', indentOn: /[({\\[]$/, moveToNewLine: /^[)}\\]]/, spellcheck: false, catchTab: true, preserveIdent: true, addClosing: true, history: true, window: globalWindow }, opt);\n    const window = options.window;\n    const document = window.document;\n    let listeners = [];\n    let history = [];\n    let at = -1;\n    let focus = false;\n    let callback;\n    let prev; // code content prior keydown event\n    editor.setAttribute('contenteditable', 'plaintext-only');\n    editor.setAttribute('spellcheck', options.spellcheck ? 'true' : 'false');\n    editor.style.outline = 'none';\n    editor.style.overflowWrap = 'break-word';\n    editor.style.overflowY = 'auto';\n    editor.style.whiteSpace = 'pre-wrap';\n    let isLegacy = false; // true if plaintext-only is not supported\n    highlight(editor);\n    if (editor.contentEditable !== 'plaintext-only')\n        isLegacy = true;\n    if (isLegacy)\n        editor.setAttribute('contenteditable', 'true');\n    const debounceHighlight = debounce(() => {\n        const pos = save();\n        highlight(editor, pos);\n        restore(pos);\n    }, 30);\n    let recording = false;\n    const shouldRecord = (event) => {\n        return !isUndo(event) && !isRedo(event)\n            && event.key !== 'Meta'\n            && event.key !== 'Control'\n            && event.key !== 'Alt'\n            && !event.key.startsWith('Arrow');\n    };\n    const debounceRecordHistory = debounce((event) => {\n        if (shouldRecord(event)) {\n            recordHistory();\n            recording = false;\n        }\n    }, 300);\n    const on = (type, fn) => {\n        listeners.push([type, fn]);\n        editor.addEventListener(type, fn);\n    };\n    on('keydown', event => {\n        if (event.defaultPrevented)\n            return;\n        prev = toString();\n        if (options.preserveIdent)\n            handleNewLine(event);\n        else\n            legacyNewLineFix(event);\n        if (options.catchTab)\n            handleTabCharacters(event);\n        if (options.addClosing)\n            handleSelfClosingCharacters(event);\n        if (options.history) {\n            handleUndoRedo(event);\n            if (shouldRecord(event) && !recording) {\n                recordHistory();\n                recording = true;\n            }\n        }\n        if (isLegacy && !isCopy(event))\n            restore(save());\n    });\n    on('keyup', event => {\n        if (event.defaultPrevented)\n            return;\n        if (event.isComposing)\n            return;\n        if (prev !== toString())\n            debounceHighlight();\n        debounceRecordHistory(event);\n        if (callback)\n            callback(toString());\n    });\n    on('focus', _event => {\n        focus = true;\n    });\n    on('blur', _event => {\n        focus = false;\n    });\n    on('paste', event => {\n        recordHistory();\n        handlePaste(event);\n        recordHistory();\n        if (callback)\n            callback(toString());\n    });\n    function save() {\n        const s = getSelection();\n        const pos = { start: 0, end: 0, dir: undefined };\n        let { anchorNode, anchorOffset, focusNode, focusOffset } = s;\n        if (!anchorNode || !focusNode)\n            throw 'error1';\n        // If the anchor and focus are the editor element, return either a full\n        // highlight or a start/end cursor position depending on the selection\n        if (anchorNode === editor && focusNode === editor) {\n            pos.start = (anchorOffset > 0 && editor.textContent) ? editor.textContent.length : 0;\n            pos.end = (focusOffset > 0 && editor.textContent) ? editor.textContent.length : 0;\n            pos.dir = (focusOffset >= anchorOffset) ? '->' : '<-';\n            return pos;\n        }\n        // Selection anchor and focus are expected to be text nodes,\n        // so normalize them.\n        if (anchorNode.nodeType === Node.ELEMENT_NODE) {\n            const node = document.createTextNode('');\n            anchorNode.insertBefore(node, anchorNode.childNodes[anchorOffset]);\n            anchorNode = node;\n            anchorOffset = 0;\n        }\n        if (focusNode.nodeType === Node.ELEMENT_NODE) {\n            const node = document.createTextNode('');\n            focusNode.insertBefore(node, focusNode.childNodes[focusOffset]);\n            focusNode = node;\n            focusOffset = 0;\n        }\n        visit(editor, el => {\n            if (el === anchorNode && el === focusNode) {\n                pos.start += anchorOffset;\n                pos.end += focusOffset;\n                pos.dir = anchorOffset <= focusOffset ? '->' : '<-';\n                return 'stop';\n            }\n            if (el === anchorNode) {\n                pos.start += anchorOffset;\n                if (!pos.dir) {\n                    pos.dir = '->';\n                }\n                else {\n                    return 'stop';\n                }\n            }\n            else if (el === focusNode) {\n                pos.end += focusOffset;\n                if (!pos.dir) {\n                    pos.dir = '<-';\n                }\n                else {\n                    return 'stop';\n                }\n            }\n            if (el.nodeType === Node.TEXT_NODE) {\n                if (pos.dir != '->')\n                    pos.start += el.nodeValue.length;\n                if (pos.dir != '<-')\n                    pos.end += el.nodeValue.length;\n            }\n        });\n        // collapse empty text nodes\n        editor.normalize();\n        return pos;\n    }\n    function restore(pos) {\n        const s = getSelection();\n        let startNode, startOffset = 0;\n        let endNode, endOffset = 0;\n        if (!pos.dir)\n            pos.dir = '->';\n        if (pos.start < 0)\n            pos.start = 0;\n        if (pos.end < 0)\n            pos.end = 0;\n        // Flip start and end if the direction reversed\n        if (pos.dir == '<-') {\n            const { start, end } = pos;\n            pos.start = end;\n            pos.end = start;\n        }\n        let current = 0;\n        visit(editor, el => {\n            if (el.nodeType !== Node.TEXT_NODE)\n                return;\n            const len = (el.nodeValue || '').length;\n            if (current + len > pos.start) {\n                if (!startNode) {\n                    startNode = el;\n                    startOffset = pos.start - current;\n                }\n                if (current + len > pos.end) {\n                    endNode = el;\n                    endOffset = pos.end - current;\n                    return 'stop';\n                }\n            }\n            current += len;\n        });\n        if (!startNode)\n            startNode = editor, startOffset = editor.childNodes.length;\n        if (!endNode)\n            endNode = editor, endOffset = editor.childNodes.length;\n        // Flip back the selection\n        if (pos.dir == '<-') {\n            [startNode, startOffset, endNode, endOffset] = [endNode, endOffset, startNode, startOffset];\n        }\n        s.setBaseAndExtent(startNode, startOffset, endNode, endOffset);\n    }\n    function beforeCursor() {\n        const s = getSelection();\n        const r0 = s.getRangeAt(0);\n        const r = document.createRange();\n        r.selectNodeContents(editor);\n        r.setEnd(r0.startContainer, r0.startOffset);\n        return r.toString();\n    }\n    function afterCursor() {\n        const s = getSelection();\n        const r0 = s.getRangeAt(0);\n        const r = document.createRange();\n        r.selectNodeContents(editor);\n        r.setStart(r0.endContainer, r0.endOffset);\n        return r.toString();\n    }\n    function handleNewLine(event) {\n        if (event.key === 'Enter') {\n            const before = beforeCursor();\n            const after = afterCursor();\n            let [padding] = findPadding(before);\n            let newLinePadding = padding;\n            // If last symbol is \"{\" ident new line\n            if (options.indentOn.test(before)) {\n                newLinePadding += options.tab;\n            }\n            // Preserve padding\n            if (newLinePadding.length > 0) {\n                preventDefault(event);\n                event.stopPropagation();\n                insert('\\n' + newLinePadding);\n            }\n            else {\n                legacyNewLineFix(event);\n            }\n            // Place adjacent \"}\" on next line\n            if (newLinePadding !== padding && options.moveToNewLine.test(after)) {\n                const pos = save();\n                insert('\\n' + padding);\n                restore(pos);\n            }\n        }\n    }\n    function legacyNewLineFix(event) {\n        // Firefox does not support plaintext-only mode\n        // and puts <div><br></div> on Enter. Let's help.\n        if (isLegacy && event.key === 'Enter') {\n            preventDefault(event);\n            event.stopPropagation();\n            if (afterCursor() == '') {\n                insert('\\n ');\n                const pos = save();\n                pos.start = --pos.end;\n                restore(pos);\n            }\n            else {\n                insert('\\n');\n            }\n        }\n    }\n    function handleSelfClosingCharacters(event) {\n        const open = `([{'\"`;\n        const close = `)]}'\"`;\n        const codeAfter = afterCursor();\n        const codeBefore = beforeCursor();\n        const escapeCharacter = codeBefore.substr(codeBefore.length - 1) === '\\\\';\n        const charAfter = codeAfter.substr(0, 1);\n        if (close.includes(event.key) && !escapeCharacter && charAfter === event.key) {\n            // We already have closing char next to cursor.\n            // Move one char to right.\n            const pos = save();\n            preventDefault(event);\n            pos.start = ++pos.end;\n            restore(pos);\n        }\n        else if (open.includes(event.key)\n            && !escapeCharacter\n            && (`\"'`.includes(event.key) || ['', ' ', '\\n'].includes(charAfter))) {\n            preventDefault(event);\n            const pos = save();\n            const wrapText = pos.start == pos.end ? '' : getSelection().toString();\n            const text = event.key + wrapText + close[open.indexOf(event.key)];\n            insert(text);\n            pos.start++;\n            pos.end++;\n            restore(pos);\n        }\n    }\n    function handleTabCharacters(event) {\n        if (event.key === 'Tab') {\n            preventDefault(event);\n            if (event.shiftKey) {\n                const before = beforeCursor();\n                let [padding, start,] = findPadding(before);\n                if (padding.length > 0) {\n                    const pos = save();\n                    // Remove full length tab or just remaining padding\n                    const len = Math.min(options.tab.length, padding.length);\n                    restore({ start, end: start + len });\n                    document.execCommand('delete');\n                    pos.start -= len;\n                    pos.end -= len;\n                    restore(pos);\n                }\n            }\n            else {\n                insert(options.tab);\n            }\n        }\n    }\n    function handleUndoRedo(event) {\n        if (isUndo(event)) {\n            preventDefault(event);\n            at--;\n            const record = history[at];\n            if (record) {\n                editor.innerHTML = record.html;\n                restore(record.pos);\n            }\n            if (at < 0)\n                at = 0;\n        }\n        if (isRedo(event)) {\n            preventDefault(event);\n            at++;\n            const record = history[at];\n            if (record) {\n                editor.innerHTML = record.html;\n                restore(record.pos);\n            }\n            if (at >= history.length)\n                at--;\n        }\n    }\n    function recordHistory() {\n        if (!focus)\n            return;\n        const html = editor.innerHTML;\n        const pos = save();\n        const lastRecord = history[at];\n        if (lastRecord) {\n            if (lastRecord.html === html\n                && lastRecord.pos.start === pos.start\n                && lastRecord.pos.end === pos.end)\n                return;\n        }\n        at++;\n        history[at] = { html, pos };\n        history.splice(at + 1);\n        const maxHistory = 300;\n        if (at > maxHistory) {\n            at = maxHistory;\n            history.splice(0, 1);\n        }\n    }\n    function handlePaste(event) {\n        preventDefault(event);\n        const text = (event.originalEvent || event)\n            .clipboardData\n            .getData('text/plain')\n            .replace(/\\r/g, '');\n        const pos = save();\n        insert(text);\n        highlight(editor);\n        restore({\n            start: Math.min(pos.start, pos.end) + text.length,\n            end: Math.min(pos.start, pos.end) + text.length,\n            dir: '<-',\n        });\n    }\n    function visit(editor, visitor) {\n        const queue = [];\n        if (editor.firstChild)\n            queue.push(editor.firstChild);\n        let el = queue.pop();\n        while (el) {\n            if (visitor(el) === 'stop')\n                break;\n            if (el.nextSibling)\n                queue.push(el.nextSibling);\n            if (el.firstChild)\n                queue.push(el.firstChild);\n            el = queue.pop();\n        }\n    }\n    function isCtrl(event) {\n        return event.metaKey || event.ctrlKey;\n    }\n    function isUndo(event) {\n        return isCtrl(event) && !event.shiftKey && getKeyCode(event) === 'Z';\n    }\n    function isRedo(event) {\n        return isCtrl(event) && event.shiftKey && getKeyCode(event) === 'Z';\n    }\n    function isCopy(event) {\n        return isCtrl(event) && getKeyCode(event) === 'C';\n    }\n    function getKeyCode(event) {\n        let key = event.key || event.keyCode || event.which;\n        if (!key)\n            return undefined;\n        return (typeof key === 'string' ? key : String.fromCharCode(key)).toUpperCase();\n    }\n    function insert(text) {\n        text = text\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#039;');\n        document.execCommand('insertHTML', false, text);\n    }\n    function debounce(cb, wait) {\n        let timeout = 0;\n        return (...args) => {\n            clearTimeout(timeout);\n            timeout = window.setTimeout(() => cb(...args), wait);\n        };\n    }\n    function findPadding(text) {\n        // Find beginning of previous line.\n        let i = text.length - 1;\n        while (i >= 0 && text[i] !== '\\n')\n            i--;\n        i++;\n        // Find padding of the line.\n        let j = i;\n        while (j < text.length && /[ \\t]/.test(text[j]))\n            j++;\n        return [text.substring(i, j) || '', i, j];\n    }\n    function toString() {\n        return editor.textContent || '';\n    }\n    function preventDefault(event) {\n        event.preventDefault();\n    }\n    function getSelection() {\n        var _a;\n        if (((_a = editor.parentNode) === null || _a === void 0 ? void 0 : _a.nodeType) == Node.DOCUMENT_FRAGMENT_NODE) {\n            return editor.parentNode.getSelection();\n        }\n        return window.getSelection();\n    }\n    return {\n        updateOptions(newOptions) {\n            Object.assign(options, newOptions);\n        },\n        updateCode(code) {\n            editor.textContent = code;\n            highlight(editor);\n        },\n        onUpdate(cb) {\n            callback = cb;\n        },\n        toString,\n        save,\n        restore,\n        recordHistory,\n        destroy() {\n            for (let [type, fn] of listeners) {\n                editor.removeEventListener(type, fn);\n            }\n        },\n    };\n}\n"],"names":["globalWindow","window","CodeJar","editor","highlight","opt","options","Object","assign","tab","indentOn","moveToNewLine","spellcheck","catchTab","preserveIdent","addClosing","history","document","callback","prev","listeners","at","focus","setAttribute","style","outline","overflowWrap","overflowY","whiteSpace","isLegacy","contentEditable","debounceHighlight","debounce","pos","save","restore","recording","shouldRecord","event","isUndo","isRedo","key","startsWith","debounceRecordHistory","recordHistory","on","type","fn","push","addEventListener","s","getSelection","start","end","dir","undefined","anchorNode","anchorOffset","focusNode","focusOffset","textContent","length","nodeType","Node","ELEMENT_NODE","node","createTextNode","insertBefore","childNodes","visit","el","TEXT_NODE","nodeValue","normalize","startNode","endNode","startOffset","endOffset","current","len","setBaseAndExtent","beforeCursor","r0","getRangeAt","r","createRange","selectNodeContents","setEnd","startContainer","toString","afterCursor","setStart","endContainer","legacyNewLineFix","preventDefault","stopPropagation","insert","html","innerHTML","lastRecord","splice","visitor","queue","firstChild","pop","nextSibling","isCtrl","metaKey","ctrlKey","shiftKey","getKeyCode","keyCode","which","String","fromCharCode","toUpperCase","text","replace","execCommand","cb","wait","timeout","args","clearTimeout","setTimeout","findPadding","i","j","test","substring","_a","parentNode","DOCUMENT_FRAGMENT_NODE","defaultPrevented","before","after","padding","newLinePadding","handleNewLine","Math","min","handleTabCharacters","open","close","codeAfter","codeBefore","escapeCharacter","substr","charAfter","includes","wrapText","indexOf","handleSelfClosingCharacters","record","handleUndoRedo","isCopy","isComposing","_event","originalEvent","clipboardData","getData","handlePaste","updateOptions","newOptions","updateCode","code","onUpdate","destroy","removeEventListener"],"sourceRoot":""}