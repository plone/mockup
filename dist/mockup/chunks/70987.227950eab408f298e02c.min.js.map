{"version":3,"file":"chunks/70987.227950eab408f298e02c.min.js","mappings":"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","sources":["webpack://@plone/mockup/./node_modules/tinymce/plugins/quickbars/plugin.js","webpack://@plone/mockup/./node_modules/tinymce/plugins/quickbars/index.js"],"sourcesContent":["/**\n * TinyMCE version 7.9.1 (2025-05-29)\n */\n\n(function () {\n    'use strict';\n\n    var global$1 = tinymce.util.Tools.resolve('tinymce.PluginManager');\n\n    /* eslint-disable @typescript-eslint/no-wrapper-object-types */\n    const hasProto = (v, constructor, predicate) => {\n        var _a;\n        if (predicate(v, constructor.prototype)) {\n            return true;\n        }\n        else {\n            // String-based fallback time\n            return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n        }\n    };\n    const typeOf = (x) => {\n        const t = typeof x;\n        if (x === null) {\n            return 'null';\n        }\n        else if (t === 'object' && Array.isArray(x)) {\n            return 'array';\n        }\n        else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n            return 'string';\n        }\n        else {\n            return t;\n        }\n    };\n    const isType = (type) => (value) => typeOf(value) === type;\n    const isSimpleType = (type) => (value) => typeof value === type;\n    const isString = isType('string');\n    const isBoolean = isSimpleType('boolean');\n    const isNullable = (a) => a === null || a === undefined;\n    const isNonNullable = (a) => !isNullable(a);\n    const isFunction = isSimpleType('function');\n\n    const constant = (value) => {\n        return () => {\n            return value;\n        };\n    };\n    const never = constant(false);\n\n    /**\n     * The `Optional` type represents a value (of any type) that potentially does\n     * not exist. Any `Optional<T>` can either be a `Some<T>` (in which case the\n     * value does exist) or a `None` (in which case the value does not exist). This\n     * module defines a whole lot of FP-inspired utility functions for dealing with\n     * `Optional` objects.\n     *\n     * Comparison with null or undefined:\n     * - We don't get fancy null coalescing operators with `Optional`\n     * - We do get fancy helper functions with `Optional`\n     * - `Optional` support nesting, and allow for the type to still be nullable (or\n     * another `Optional`)\n     * - There is no option to turn off strict-optional-checks like there is for\n     * strict-null-checks\n     */\n    class Optional {\n        // The internal representation has a `tag` and a `value`, but both are\n        // private: able to be console.logged, but not able to be accessed by code\n        constructor(tag, value) {\n            this.tag = tag;\n            this.value = value;\n        }\n        // --- Identities ---\n        /**\n         * Creates a new `Optional<T>` that **does** contain a value.\n         */\n        static some(value) {\n            return new Optional(true, value);\n        }\n        /**\n         * Create a new `Optional<T>` that **does not** contain a value. `T` can be\n         * any type because we don't actually have a `T`.\n         */\n        static none() {\n            return Optional.singletonNone;\n        }\n        /**\n         * Perform a transform on an `Optional` type. Regardless of whether this\n         * `Optional` contains a value or not, `fold` will return a value of type `U`.\n         * If this `Optional` does not contain a value, the `U` will be created by\n         * calling `onNone`. If this `Optional` does contain a value, the `U` will be\n         * created by calling `onSome`.\n         *\n         * For the FP enthusiasts in the room, this function:\n         * 1. Could be used to implement all of the functions below\n         * 2. Forms a catamorphism\n         */\n        fold(onNone, onSome) {\n            if (this.tag) {\n                return onSome(this.value);\n            }\n            else {\n                return onNone();\n            }\n        }\n        /**\n         * Determine if this `Optional` object contains a value.\n         */\n        isSome() {\n            return this.tag;\n        }\n        /**\n         * Determine if this `Optional` object **does not** contain a value.\n         */\n        isNone() {\n            return !this.tag;\n        }\n        // --- Functor (name stolen from Haskell / maths) ---\n        /**\n         * Perform a transform on an `Optional` object, **if** there is a value. If\n         * you provide a function to turn a T into a U, this is the function you use\n         * to turn an `Optional<T>` into an `Optional<U>`. If this **does** contain\n         * a value then the output will also contain a value (that value being the\n         * output of `mapper(this.value)`), and if this **does not** contain a value\n         * then neither will the output.\n         */\n        map(mapper) {\n            if (this.tag) {\n                return Optional.some(mapper(this.value));\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Monad (name stolen from Haskell / maths) ---\n        /**\n         * Perform a transform on an `Optional` object, **if** there is a value.\n         * Unlike `map`, here the transform itself also returns an `Optional`.\n         */\n        bind(binder) {\n            if (this.tag) {\n                return binder(this.value);\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Traversable (name stolen from Haskell / maths) ---\n        /**\n         * For a given predicate, this function finds out if there **exists** a value\n         * inside this `Optional` object that meets the predicate. In practice, this\n         * means that for `Optional`s that do not contain a value it returns false (as\n         * no predicate-meeting value exists).\n         */\n        exists(predicate) {\n            return this.tag && predicate(this.value);\n        }\n        /**\n         * For a given predicate, this function finds out if **all** the values inside\n         * this `Optional` object meet the predicate. In practice, this means that\n         * for `Optional`s that do not contain a value it returns true (as all 0\n         * objects do meet the predicate).\n         */\n        forall(predicate) {\n            return !this.tag || predicate(this.value);\n        }\n        filter(predicate) {\n            if (!this.tag || predicate(this.value)) {\n                return this;\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Getters ---\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value.\n         */\n        getOr(replacement) {\n            return this.tag ? this.value : replacement;\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value.  Unlike `getOr`, in this method the `replacement` object is also\n         * `Optional` - meaning that this method will always return an `Optional`.\n         */\n        or(replacement) {\n            return this.tag ? this : replacement;\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value. Unlike `getOr`, in this method the `replacement` value is\n         * \"thunked\" - that is to say that you don't pass a value to `getOrThunk`, you\n         * pass a function which (if called) will **return** the `value` you want to\n         * use.\n         */\n        getOrThunk(thunk) {\n            return this.tag ? this.value : thunk();\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided Optional object does not contain a\n         * value.\n         *\n         * Unlike `or`, in this method the `replacement` value is \"thunked\" - that is\n         * to say that you don't pass a value to `orThunk`, you pass a function which\n         * (if called) will **return** the `value` you want to use.\n         *\n         * Unlike `getOrThunk`, in this method the `replacement` value is also\n         * `Optional`, meaning that this method will always return an `Optional`.\n         */\n        orThunk(thunk) {\n            return this.tag ? this : thunk();\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, throwing an\n         * exception if the provided `Optional` object does not contain a value.\n         *\n         * WARNING:\n         * You should only be using this function if you know that the `Optional`\n         * object **is not** empty (otherwise you're throwing exceptions in production\n         * code, which is bad).\n         *\n         * In tests this is more acceptable.\n         *\n         * Prefer other methods to this, such as `.each`.\n         */\n        getOrDie(message) {\n            if (!this.tag) {\n                throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n            }\n            else {\n                return this.value;\n            }\n        }\n        // --- Interop with null and undefined ---\n        /**\n         * Creates an `Optional` value from a nullable (or undefined-able) input.\n         * Null, or undefined, is converted to `None`, and anything else is converted\n         * to `Some`.\n         */\n        static from(value) {\n            return isNonNullable(value) ? Optional.some(value) : Optional.none();\n        }\n        /**\n         * Converts an `Optional` to a nullable type, by getting the value if it\n         * exists, or returning `null` if it does not.\n         */\n        getOrNull() {\n            return this.tag ? this.value : null;\n        }\n        /**\n         * Converts an `Optional` to an undefined-able type, by getting the value if\n         * it exists, or returning `undefined` if it does not.\n         */\n        getOrUndefined() {\n            return this.value;\n        }\n        // --- Utilities ---\n        /**\n         * If the `Optional` contains a value, perform an action on that value.\n         * Unlike the rest of the methods on this type, `.each` has side-effects. If\n         * you want to transform an `Optional<T>` **into** something, then this is not\n         * the method for you. If you want to use an `Optional<T>` to **do**\n         * something, then this is the method for you - provided you're okay with not\n         * doing anything in the case where the `Optional` doesn't have a value inside\n         * it. If you're not sure whether your use-case fits into transforming\n         * **into** something or **doing** something, check whether it has a return\n         * value. If it does, you should be performing a transform.\n         */\n        each(worker) {\n            if (this.tag) {\n                worker(this.value);\n            }\n        }\n        /**\n         * Turn the `Optional` object into an array that contains all of the values\n         * stored inside the `Optional`. In practice, this means the output will have\n         * either 0 or 1 elements.\n         */\n        toArray() {\n            return this.tag ? [this.value] : [];\n        }\n        /**\n         * Turn the `Optional` object into a string for debugging or printing. Not\n         * recommended for production code, but good for debugging. Also note that\n         * these days an `Optional` object can be logged to the console directly, and\n         * its inner value (if it exists) will be visible.\n         */\n        toString() {\n            return this.tag ? `some(${this.value})` : 'none()';\n        }\n    }\n    // Sneaky optimisation: every instance of Optional.none is identical, so just\n    // reuse the same object\n    Optional.singletonNone = new Optional(false);\n\n    /**\n     * Adds two numbers, and wrap to a range.\n     * If the result overflows to the right, snap to the left.\n     * If the result overflows to the left, snap to the right.\n     */\n    // the division is meant to get a number between 0 and 1 for more information check this discussion: https://stackoverflow.com/questions/58285941/how-to-replace-math-random-with-crypto-getrandomvalues-and-keep-same-result\n    const random = () => window.crypto.getRandomValues(new Uint32Array(1))[0] / 4294967295;\n\n    /**\n     * Generate a unique identifier.\n     *\n     * The unique portion of the identifier only contains an underscore\n     * and digits, so that it may safely be used within HTML attributes.\n     *\n     * The chance of generating a non-unique identifier has been minimized\n     * by combining the current time, a random number and a one-up counter.\n     *\n     * generate :: String -> String\n     */\n    let unique = 0;\n    const generate = (prefix) => {\n        const date = new Date();\n        const time = date.getTime();\n        const random$1 = Math.floor(random() * 1000000000);\n        unique++;\n        return prefix + '_' + random$1 + unique + String(time);\n    };\n\n    const insertTable = (editor, columns, rows) => {\n        editor.execCommand('mceInsertTable', false, { rows, columns });\n    };\n    const insertBlob = (editor, base64, blob) => {\n        const blobCache = editor.editorUpload.blobCache;\n        const blobInfo = blobCache.create(generate('mceu'), blob, base64);\n        blobCache.add(blobInfo);\n        editor.insertContent(editor.dom.createHTML('img', { src: blobInfo.blobUri() }));\n    };\n\n    const blobToBase64 = (blob) => {\n        return new Promise((resolve) => {\n            const reader = new FileReader();\n            reader.onloadend = () => {\n                resolve(reader.result.split(',')[1]);\n            };\n            reader.readAsDataURL(blob);\n        });\n    };\n\n    var global = tinymce.util.Tools.resolve('tinymce.util.Delay');\n\n    const pickFile = (editor) => new Promise((resolve) => {\n        let resolved = false;\n        const fileInput = document.createElement('input');\n        fileInput.type = 'file';\n        fileInput.accept = 'image/*';\n        fileInput.style.position = 'fixed';\n        fileInput.style.left = '0';\n        fileInput.style.top = '0';\n        fileInput.style.opacity = '0.001';\n        document.body.appendChild(fileInput);\n        const resolveFileInput = (value) => {\n            var _a;\n            if (!resolved) {\n                (_a = fileInput.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(fileInput);\n                resolved = true;\n                resolve(value);\n            }\n        };\n        const changeHandler = (e) => {\n            resolveFileInput(Array.prototype.slice.call(e.target.files));\n        };\n        fileInput.addEventListener('input', changeHandler);\n        fileInput.addEventListener('change', changeHandler);\n        const cancelHandler = (e) => {\n            const cleanup = () => {\n                resolveFileInput([]);\n            };\n            if (!resolved) {\n                if (e.type === 'focusin') {\n                    // Chrome will fire `focusin` before the input `change` event\n                    global.setEditorTimeout(editor, cleanup, 1000);\n                }\n                else {\n                    cleanup();\n                }\n            }\n            editor.off('focusin remove', cancelHandler);\n        };\n        editor.on('focusin remove', cancelHandler);\n        fileInput.click();\n    });\n\n    const register$1 = (editor) => {\n        editor.on('PreInit', () => {\n            if (!editor.queryCommandSupported('QuickbarInsertImage')) {\n                editor.addCommand('QuickbarInsertImage', () => {\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                    pickFile(editor).then((files) => {\n                        if (files.length > 0) {\n                            const blob = files[0];\n                            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                            blobToBase64(blob).then((base64) => {\n                                insertBlob(editor, base64, blob);\n                            });\n                        }\n                    });\n                });\n            }\n        });\n    };\n\n    const option = (name) => (editor) => editor.options.get(name);\n    const register = (editor) => {\n        const registerOption = editor.options.register;\n        const toolbarProcessor = (defaultValue) => (value) => {\n            const valid = isBoolean(value) || isString(value);\n            if (valid) {\n                if (isBoolean(value)) {\n                    return { value: value ? defaultValue : '', valid };\n                }\n                else {\n                    return { value: value.trim(), valid };\n                }\n            }\n            else {\n                return { valid: false, message: 'Must be a boolean or string.' };\n            }\n        };\n        const defaultSelectionToolbar = 'bold italic | quicklink h2 h3 blockquote';\n        registerOption('quickbars_selection_toolbar', {\n            processor: toolbarProcessor(defaultSelectionToolbar),\n            default: defaultSelectionToolbar\n        });\n        const defaultInsertToolbar = 'quickimage quicktable';\n        registerOption('quickbars_insert_toolbar', {\n            processor: toolbarProcessor(defaultInsertToolbar),\n            default: defaultInsertToolbar\n        });\n        const defaultImageToolbar = 'alignleft aligncenter alignright';\n        registerOption('quickbars_image_toolbar', {\n            processor: toolbarProcessor(defaultImageToolbar),\n            default: defaultImageToolbar\n        });\n    };\n    const getTextSelectionToolbarItems = option('quickbars_selection_toolbar');\n    const getInsertToolbarItems = option('quickbars_insert_toolbar');\n    const getImageToolbarItems = option('quickbars_image_toolbar');\n\n    const setupButtons = (editor) => {\n        editor.ui.registry.addButton('quickimage', {\n            icon: 'image',\n            tooltip: 'Insert image',\n            onAction: () => editor.execCommand('QuickbarInsertImage')\n        });\n        editor.ui.registry.addButton('quicktable', {\n            icon: 'table',\n            tooltip: 'Insert table',\n            onAction: () => {\n                insertTable(editor, 2, 2);\n            }\n        });\n    };\n\n    const fromHtml = (html, scope) => {\n        const doc = scope || document;\n        const div = doc.createElement('div');\n        div.innerHTML = html;\n        if (!div.hasChildNodes() || div.childNodes.length > 1) {\n            const message = 'HTML does not have a single root node';\n            // eslint-disable-next-line no-console\n            console.error(message, html);\n            throw new Error(message);\n        }\n        return fromDom(div.childNodes[0]);\n    };\n    const fromTag = (tag, scope) => {\n        const doc = scope || document;\n        const node = doc.createElement(tag);\n        return fromDom(node);\n    };\n    const fromText = (text, scope) => {\n        const doc = scope || document;\n        const node = doc.createTextNode(text);\n        return fromDom(node);\n    };\n    const fromDom = (node) => {\n        // TODO: Consider removing this check, but left atm for safety\n        if (node === null || node === undefined) {\n            throw new Error('Node cannot be null or undefined');\n        }\n        return {\n            dom: node\n        };\n    };\n    const fromPoint = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom);\n    // tslint:disable-next-line:variable-name\n    const SugarElement = {\n        fromHtml,\n        fromTag,\n        fromText,\n        fromDom,\n        fromPoint\n    };\n\n    const ELEMENT = 1;\n\n    const is = (element, selector) => {\n        const dom = element.dom;\n        if (dom.nodeType !== ELEMENT) {\n            return false;\n        }\n        else {\n            const elem = dom;\n            if (elem.matches !== undefined) {\n                return elem.matches(selector);\n            }\n            else if (elem.msMatchesSelector !== undefined) {\n                return elem.msMatchesSelector(selector);\n            }\n            else if (elem.webkitMatchesSelector !== undefined) {\n                return elem.webkitMatchesSelector(selector);\n            }\n            else if (elem.mozMatchesSelector !== undefined) {\n                // cast to any as mozMatchesSelector doesn't exist in TS DOM lib\n                return elem.mozMatchesSelector(selector);\n            }\n            else {\n                throw new Error('Browser lacks native selectors');\n            } // unfortunately we can't throw this on startup :(\n        }\n    };\n\n    const name = (element) => {\n        const r = element.dom.nodeName;\n        return r.toLowerCase();\n    };\n\n    const has$1 = (element, key) => {\n        const dom = element.dom;\n        // return false for non-element nodes, no point in throwing an error\n        return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;\n    };\n\n    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {\n        if (is(scope, a)) {\n            return Optional.some(scope);\n        }\n        else if (isFunction(isRoot) && isRoot(scope)) {\n            return Optional.none();\n        }\n        else {\n            return ancestor(scope, a, isRoot);\n        }\n    };\n\n    const ancestor$1 = (scope, predicate, isRoot) => {\n        let element = scope.dom;\n        const stop = isFunction(isRoot) ? isRoot : never;\n        while (element.parentNode) {\n            element = element.parentNode;\n            const el = SugarElement.fromDom(element);\n            if (predicate(el)) {\n                return Optional.some(el);\n            }\n            else if (stop(el)) {\n                break;\n            }\n        }\n        return Optional.none();\n    };\n    const closest$2 = (scope, predicate, isRoot) => {\n        // This is required to avoid ClosestOrAncestor passing the predicate to itself\n        const is = (s, test) => test(s);\n        return ClosestOrAncestor(is, ancestor$1, scope, predicate, isRoot);\n    };\n\n    const ancestor = (scope, selector, isRoot) => ancestor$1(scope, (e) => is(e, selector), isRoot);\n    // Returns Some(closest ancestor element (sugared)) matching 'selector' up to isRoot, or None() otherwise\n    const closest$1 = (scope, selector, isRoot) => {\n        const is$1 = (element, selector) => is(element, selector);\n        return ClosestOrAncestor(is$1, ancestor, scope, selector, isRoot);\n    };\n\n    // IE11 Can return undefined for a classList on elements such as math, so we make sure it's not undefined before attempting to use it.\n    const supports = (element) => element.dom.classList !== undefined;\n\n    const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);\n\n    const closest = (scope, predicate, isRoot) => closest$2(scope, predicate, isRoot).isSome();\n\n    const addToEditor$1 = (editor) => {\n        const insertToolbarItems = getInsertToolbarItems(editor);\n        if (insertToolbarItems.length > 0) {\n            editor.ui.registry.addContextToolbar('quickblock', {\n                predicate: (node) => {\n                    const sugarNode = SugarElement.fromDom(node);\n                    const textBlockElementsMap = editor.schema.getTextBlockElements();\n                    const isRoot = (elem) => elem.dom === editor.getBody();\n                    return !has$1(sugarNode, 'data-mce-bogus') && closest$1(sugarNode, 'table,[data-mce-bogus=\"all\"]', isRoot).fold(() => closest(sugarNode, (elem) => name(elem) in textBlockElementsMap && editor.dom.isEmpty(elem.dom), isRoot), never);\n                },\n                items: insertToolbarItems,\n                position: 'line',\n                scope: 'editor'\n            });\n        }\n    };\n\n    const addToEditor = (editor) => {\n        const isEditable = (node) => editor.dom.isEditable(node);\n        const isInEditableContext = (el) => isEditable(el.parentElement);\n        const isImage = (node) => {\n            const isImageFigure = node.nodeName === 'FIGURE' && /image/i.test(node.className);\n            const isImage = node.nodeName === 'IMG' || isImageFigure;\n            const isPagebreak = has(SugarElement.fromDom(node), 'mce-pagebreak');\n            return isImage && isInEditableContext(node) && !isPagebreak;\n        };\n        const imageToolbarItems = getImageToolbarItems(editor);\n        if (imageToolbarItems.length > 0) {\n            editor.ui.registry.addContextToolbar('imageselection', {\n                predicate: isImage,\n                items: imageToolbarItems,\n                position: 'node'\n            });\n        }\n        const textToolbarItems = getTextSelectionToolbarItems(editor);\n        if (textToolbarItems.length > 0) {\n            editor.ui.registry.addContextToolbar('textselection', {\n                predicate: (node) => !isImage(node) && !editor.selection.isCollapsed() && isEditable(node),\n                items: textToolbarItems,\n                position: 'selection',\n                scope: 'editor'\n            });\n        }\n    };\n\n    var Plugin = () => {\n        global$1.add('quickbars', (editor) => {\n            register(editor);\n            register$1(editor);\n            setupButtons(editor);\n            addToEditor$1(editor);\n            addToEditor(editor);\n        });\n    };\n\n    Plugin();\n    /** *****\n     * DO NOT EXPORT ANYTHING\n     *\n     * IF YOU DO ROLLUP WILL LEAVE A GLOBAL ON THE PAGE\n     *******/\n\n})();\n","// Exports the \"quickbars\" plugin for usage with module loaders\n// Usage:\n//   CommonJS:\n//     require('tinymce/plugins/quickbars')\n//   ES2015:\n//     import 'tinymce/plugins/quickbars'\nrequire('./plugin.js');"],"names":["global$1","tinymce","util","Tools","resolve","isSimpleType","type","value","isString","x","t","Array","isArray","o","v","constructor","String","prototype","isPrototypeOf","_a","name","typeOf","isBoolean","isFunction","never","Optional","tag","this","some","none","singletonNone","fold","onNone","onSome","isSome","isNone","map","mapper","bind","binder","exists","predicate","forall","filter","getOr","replacement","or","getOrThunk","thunk","orThunk","getOrDie","message","Error","from","a","isNullable","getOrNull","getOrUndefined","each","worker","toArray","toString","unique","generate","prefix","time","Date","getTime","random$1","Math","floor","window","crypto","getRandomValues","Uint32Array","global","register$1","editor","on","queryCommandSupported","addCommand","Promise","resolved","fileInput","document","createElement","accept","style","position","left","top","opacity","body","appendChild","resolveFileInput","parentNode","removeChild","changeHandler","e","slice","call","target","files","addEventListener","cancelHandler","cleanup","setEditorTimeout","off","click","pickFile","then","length","blob","reader","FileReader","onloadend","result","split","readAsDataURL","blobToBase64","base64","blobCache","editorUpload","blobInfo","create","add","insertContent","dom","createHTML","src","blobUri","insertBlob","option","options","get","getTextSelectionToolbarItems","getInsertToolbarItems","getImageToolbarItems","fromDom","node","SugarElement","fromHtml","html","scope","div","innerHTML","hasChildNodes","childNodes","console","error","fromTag","fromText","text","createTextNode","fromPoint","docElm","y","elementFromPoint","is","element","selector","nodeType","elem","undefined","matches","msMatchesSelector","webkitMatchesSelector","mozMatchesSelector","ClosestOrAncestor","ancestor","isRoot","ancestor$1","stop","el","closest","s","test","closest$2","addToEditor$1","insertToolbarItems","ui","registry","addContextToolbar","sugarNode","textBlockElementsMap","schema","getTextBlockElements","getBody","key","hasAttribute","has$1","closest$1","nodeName","toLowerCase","isEmpty","items","addToEditor","isEditable","isImage","isImageFigure","className","isPagebreak","clazz","classList","supports","contains","parentElement","imageToolbarItems","textToolbarItems","selection","isCollapsed","registerOption","register","toolbarProcessor","defaultValue","valid","trim","defaultSelectionToolbar","processor","default","defaultInsertToolbar","defaultImageToolbar","addButton","icon","tooltip","onAction","execCommand","columns","rows","insertTable","setupButtons"],"sourceRoot":""}